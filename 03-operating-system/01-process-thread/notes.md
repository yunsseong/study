# 프로세스 & 스레드

## 프로세스 (Process)

### 개념
- **실행 중인 프로그램**
- 프로그램: 디스크에 저장된 정적인 코드
- 프로세스: 메모리에 적재되어 CPU를 할당받아 실행되는 상태

### 프로세스 메모리 구조

```
높은 주소 ┌──────────────┐
         │    Stack     │ ← 지역 변수, 함수 호출 (위에서 아래로 성장)
         │      ↓       │
         │              │
         │      ↑       │
         │    Heap      │ ← 동적 할당 (malloc, new) (아래에서 위로 성장)
         ├──────────────┤
         │    BSS       │ ← 초기화되지 않은 전역/정적 변수
         ├──────────────┤
         │    Data      │ ← 초기화된 전역/정적 변수
         ├──────────────┤
낮은 주소 │    Code(Text)│ ← 실행할 코드 (읽기 전용)
         └──────────────┘
```

### 프로세스 상태 (Process State)

```
         ┌─────── 생성 (New)
         │
         ↓
      준비 (Ready) ──디스패치──→ 실행 (Running)
         ↑                         │    │
         │      타이머 인터럽트     │    │
         └─────────────────────────┘    │
                                        │
                          I/O 요청 등   │  종료
                                ↓       ↓
                          대기 (Waiting)  종료 (Terminated)
                               │
                     I/O 완료  │
                               ↓
                          준비 (Ready)
```

| 상태 | 설명 |
|------|------|
| New | 프로세스 생성 중 |
| **Ready** | CPU 할당을 기다리는 상태 (메모리에 있음) |
| **Running** | CPU를 점유하여 실행 중 |
| **Waiting (Blocked)** | I/O 완료 등 이벤트를 기다리는 상태 |
| Terminated | 실행 완료 |

---

### PCB (Process Control Block)

운영체제가 각 프로세스를 관리하기 위한 **자료구조**.

| 필드 | 내용 |
|------|------|
| PID | 프로세스 식별 번호 |
| 프로세스 상태 | Ready, Running, Waiting 등 |
| 프로그램 카운터 (PC) | 다음에 실행할 명령어 주소 |
| CPU 레지스터 | 레지스터 값들의 스냅샷 |
| 메모리 관리 정보 | 페이지 테이블, 세그먼트 테이블 |
| I/O 상태 정보 | 열린 파일, 할당된 장치 |
| 스케줄링 정보 | 우선순위, 큐 포인터 |

---

### 컨텍스트 스위칭 (Context Switching)

CPU가 한 프로세스에서 다른 프로세스로 전환하는 과정.

```
프로세스 A 실행 중
    │
    ├── ① 인터럽트 / 시스템 콜 발생
    ├── ② 프로세스 A의 상태를 PCB_A에 저장
    ├── ③ 프로세스 B의 상태를 PCB_B에서 복원
    ├── ④ 프로세스 B 실행 시작
    │
프로세스 B 실행 중
```

**컨텍스트 스위칭 비용**:
- PCB 저장/복원에 시간 소요
- 캐시 무효화 (Cache flush) → 캐시 미스 증가
- 순수 **오버헤드** (이 시간 동안 유용한 작업 불가)

---

## 스레드 (Thread)

### 개념
- 프로세스 내에서의 **실행 흐름 단위**
- 하나의 프로세스는 여러 스레드를 가질 수 있음
- "경량 프로세스 (Lightweight Process)"

### 스레드의 메모리 구조

```
프로세스
┌──────────────────────────┐
│   Code   │   Data   │  Heap  │  ← 스레드 간 공유
├──────────────────────────┤
│  Stack_1 │ Stack_2  │ Stack_3│  ← 각 스레드 독립
│ (스레드1)│(스레드2) │(스레드3)│
└──────────────────────────┘
```

**공유**: Code, Data, Heap, 파일 디스크립터
**독립**: Stack, PC(프로그램 카운터), 레지스터

---

## 프로세스 vs 스레드 (면접 핵심)

| 비교 | 프로세스 | 스레드 |
|------|---------|--------|
| 정의 | 실행 중인 프로그램 | 프로세스 내 실행 단위 |
| 메모리 | 독립된 메모리 공간 | 프로세스 메모리 공유 |
| 생성 비용 | 높음 (fork) | 낮음 |
| 컨텍스트 스위칭 | 비용 높음 (캐시 무효화) | 비용 낮음 (공유 메모리) |
| 통신 | IPC 필요 (파이프, 소켓 등) | 공유 메모리로 직접 통신 |
| 안정성 | 하나 죽어도 다른 프로세스 영향 없음 | 하나 죽으면 전체 프로세스 영향 |
| 동기화 | 불필요 (독립) | 필요 (공유 자원 경쟁) |

### 왜 멀티 스레드를 사용하나?

```
장점:
- 자원 공유: 프로세스 내 메모리를 공유하므로 효율적
- 빠른 생성/전환: 프로세스보다 오버헤드 적음
- 응답성: 하나의 스레드가 블로킹되어도 다른 스레드 실행 가능

단점:
- 동기화 문제: 공유 자원 접근 시 경쟁 조건 (Race Condition)
- 디버깅 어려움: 비결정적 실행 순서
- 하나의 스레드 오류 → 전체 프로세스 영향
```

---

## 멀티 프로세스 vs 멀티 스레드

| 비교 | 멀티 프로세스 | 멀티 스레드 |
|------|-------------|------------|
| 메모리 | 각자 독립 | 공유 |
| 안정성 | 높음 (격리) | 낮음 (전파) |
| 통신 비용 | 높음 (IPC) | 낮음 (공유 메모리) |
| 동기화 | 불필요 | 필요 |
| 예시 | Chrome 탭 (각 탭이 프로세스) | Java 서버 (요청마다 스레드) |

### 실제 사례

```
Chrome 브라우저: 멀티 프로세스
- 각 탭이 독립 프로세스 → 한 탭 크래시해도 다른 탭 안전
- 메모리는 많이 사용하지만 안정성 확보

웹 서버 (Spring): 멀티 스레드
- 요청마다 스레드 할당 → 빠른 처리
- 스레드 풀로 자원 관리

Node.js: 싱글 스레드 + 이벤트 루프
- 메인 스레드 1개 + 비동기 I/O
- I/O 바운드 작업에 효율적
```

---

## IPC (Inter-Process Communication)

프로세스 간 통신 방법.

| 방식 | 설명 | 특징 |
|------|------|------|
| 파이프 (Pipe) | 단방향 데이터 흐름 | 부모-자식 프로세스 간 |
| 명명 파이프 (Named Pipe) | 이름 있는 파이프 | 무관한 프로세스 간 가능 |
| 메시지 큐 | 커널의 메시지 큐 활용 | 비동기 통신 |
| 공유 메모리 | 같은 메모리 영역 공유 | 가장 빠름, 동기화 필요 |
| 소켓 | 네트워크 통신 | 다른 머신 간에도 가능 |
| 시그널 | 이벤트 알림 | 비동기, 간단한 알림 |

---

## 시스템 콜 & 인터럽트

### 유저 모드 vs 커널 모드

```
유저 모드 (User Mode):
- 일반 응용 프로그램 실행
- 하드웨어 직접 접근 불가
- 제한된 명령어만 실행

커널 모드 (Kernel Mode):
- OS 커널 코드 실행
- 모든 하드웨어/메모리 접근 가능
- 특권 명령어 실행 가능
```

### 시스템 콜 (System Call)

유저 모드에서 커널 기능을 요청하는 인터페이스.

```
응용 프로그램 (유저 모드)
    │
    │  시스템 콜 (예: open, read, write, fork)
    ↓
OS 커널 (커널 모드)
    │
    │  하드웨어 접근
    ↓
하드웨어
```

| 분류 | 시스템 콜 | 설명 |
|------|----------|------|
| 프로세스 | fork(), exec(), exit(), wait() | 프로세스 생성/종료 |
| 파일 | open(), read(), write(), close() | 파일 I/O |
| 메모리 | mmap(), brk() | 메모리 할당 |
| 네트워크 | socket(), bind(), listen(), accept() | 소켓 통신 |

### 인터럽트 (Interrupt)

CPU에게 **이벤트 발생을 알리는** 메커니즘.

| 종류 | 원인 | 예시 |
|------|------|------|
| 하드웨어 인터럽트 | 외부 장치 | 키보드 입력, 디스크 I/O 완료 |
| 소프트웨어 인터럽트 (트랩) | 프로그램 내부 | 시스템 콜, 예외 (0 나누기) |

```
인터럽트 처리 과정:
1. 인터럽트 발생
2. 현재 작업 상태 저장 (PCB)
3. 인터럽트 핸들러 실행 (커널 모드)
4. 처리 완료 후 원래 작업 복원
```

---

## 면접 예상 질문

1. **프로세스와 스레드의 차이점은?**
   - 메모리 공유 여부, 생성 비용, 안정성, 통신 방법

2. **컨텍스트 스위칭이란?**
   - CPU가 프로세스를 전환할 때 PCB 저장/복원하는 과정, 오버헤드 발생

3. **멀티 프로세스 vs 멀티 스레드를 각각 언제 쓰나요?**
   - 안정성 중요 → 멀티 프로세스 / 성능·자원 공유 중요 → 멀티 스레드

4. **프로세스의 메모리 구조를 설명해주세요**
   - Code, Data, BSS, Heap, Stack 영역

5. **유저 모드와 커널 모드의 차이는?**
   - 유저: 제한된 접근 / 커널: 모든 하드웨어 접근 가능

6. **IPC 방법에는 어떤 것들이 있나요?**
   - 파이프, 공유 메모리, 메시지 큐, 소켓, 시그널
