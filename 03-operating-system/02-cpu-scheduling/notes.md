# CPU 스케줄링

## 개념

- **Ready 큐**에 있는 프로세스 중 어떤 것에 CPU를 할당할지 결정하는 것
- 목표: CPU 사용률 극대화, 응답 시간 최소화, 공정성

### 스케줄링 기준

| 기준 | 설명 | 목표 |
|------|------|------|
| CPU 이용률 | CPU가 일하는 비율 | 높을수록 좋음 |
| 처리량 (Throughput) | 단위 시간당 완료된 프로세스 수 | 높을수록 좋음 |
| 대기 시간 | Ready 큐에서 기다린 시간 | 낮을수록 좋음 |
| 응답 시간 | 요청 후 첫 응답까지 시간 | 낮을수록 좋음 |
| 반환 시간 (Turnaround) | 제출 ~ 완료까지 전체 시간 | 낮을수록 좋음 |

---

## 선점 vs 비선점

| 구분 | 선점 (Preemptive) | 비선점 (Non-preemptive) |
|------|-------------------|------------------------|
| 정의 | 실행 중인 프로세스를 강제로 빼앗을 수 있음 | 프로세스가 스스로 CPU를 반납할 때까지 대기 |
| 응답 시간 | 짧음 (빠른 전환) | 길 수 있음 |
| 컨텍스트 스위칭 | 많음 (오버헤드) | 적음 |
| 예시 | RR, SRT, 다단계 큐 | FCFS, SJF, Priority (비선점) |

---

## 스케줄링 알고리즘

### 1. FCFS (First Come First Served)

**먼저 온 순서대로** 처리. 비선점.

```
프로세스: P1(24ms), P2(3ms), P3(3ms)
도착 순서: P1 → P2 → P3

|--- P1(24) ---|-- P2(3) --|-- P3(3) --|
0              24          27          30

평균 대기 시간: (0 + 24 + 27) / 3 = 17ms
```

- 장점: 구현 간단
- 단점: **Convoy Effect** - 긴 프로세스 뒤에 짧은 프로세스가 오래 대기

---

### 2. SJF (Shortest Job First)

**실행 시간이 가장 짧은 것** 먼저. 비선점.

```
프로세스: P1(6ms), P2(8ms), P3(7ms), P4(3ms)

|-- P4(3) --|--- P1(6) ---|--- P3(7) ---|--- P2(8) ---|
0           3             9             16            24

평균 대기 시간: (3 + 16 + 9 + 0) / 4 = 7ms
```

- 장점: 평균 대기 시간 **최소** (최적)
- 단점: 실행 시간 예측 불가, **기아(Starvation)** 발생 (긴 프로세스가 계속 밀림)

#### SRT (Shortest Remaining Time) - SJF의 선점 버전

남은 시간이 가장 짧은 프로세스에게 CPU를 빼앗아 줌.

---

### 3. Priority Scheduling

**우선순위가 높은 것** 먼저. 선점/비선점 모두 가능.

```
프로세스: P1(우선순위3), P2(우선순위1), P3(우선순위2)
(숫자가 작을수록 높은 우선순위)

실행 순서: P2 → P3 → P1
```

- 단점: **기아(Starvation)** - 낮은 우선순위가 영원히 실행 못함
- 해결: **에이징(Aging)** - 오래 기다린 프로세스의 우선순위를 점진적으로 높임

---

### 4. Round Robin (RR)

**시간 할당량(Time Quantum)만큼** 번갈아가며 실행. 선점.

```
Time Quantum = 4ms
프로세스: P1(24ms), P2(3ms), P3(3ms)

|P1(4)|P2(3)|P3(3)|P1(4)|P1(4)|P1(4)|P1(4)|P1(4)|
0     4     7     10    14    18    22    26    30

평균 대기 시간: (6 + 4 + 7) / 3 = 5.67ms
```

- 장점: **공정**, 응답 시간 빠름, 기아 없음
- 단점: 컨텍스트 스위칭 오버헤드
- **Time Quantum 크기가 중요**:
  - 너무 크면 → FCFS와 같아짐
  - 너무 작으면 → 컨텍스트 스위칭 오버헤드 증가
  - 적정: 10~100ms

---

### 5. 다단계 큐 (Multilevel Queue)

프로세스를 **여러 큐로 분류**, 각 큐마다 다른 스케줄링 적용.

```
┌────────────────────────┐ 높은 우선순위
│  시스템 프로세스 (FCFS)  │
├────────────────────────┤
│  대화형 프로세스 (RR)    │
├────────────────────────┤
│  배치 프로세스 (FCFS)    │ 낮은 우선순위
└────────────────────────┘
```

### 6. 다단계 피드백 큐 (Multilevel Feedback Queue)

프로세스가 **큐 사이를 이동** 가능. 가장 일반적으로 사용.

```
Q0 (Time Quantum = 8ms)   ← 새 프로세스는 여기서 시작
  │ 할당량 내 완료 못하면
  ↓
Q1 (Time Quantum = 16ms)  ← 한 단계 아래로
  │ 할당량 내 완료 못하면
  ↓
Q2 (FCFS)                  ← 최하위 큐
```

- CPU burst가 짧은 프로세스(대화형) → 상위 큐에서 빨리 처리
- CPU burst가 긴 프로세스(배치) → 하위 큐로 이동
- 에이징 적용: 오래 기다리면 상위 큐로 승격

---

## 알고리즘 비교 정리

| 알고리즘 | 선점 | 기아 | 특징 |
|---------|------|------|------|
| FCFS | 비선점 | X | 간단, Convoy Effect |
| SJF | 비선점 | O | 평균 대기 최소 (이론적 최적) |
| SRT | 선점 | O | SJF의 선점 버전 |
| Priority | 둘 다 | O | 에이징으로 기아 해결 |
| **RR** | 선점 | X | 공정, 응답 빠름, TQ 크기 중요 |
| MLFQ | 선점 | X | 실무에서 가장 많이 사용 |

---

## CPU 바운드 vs I/O 바운드

| 유형 | 특징 | 스케줄링 |
|------|------|---------|
| CPU 바운드 | 계산 위주, 긴 CPU burst | 낮은 우선순위 |
| I/O 바운드 | I/O 위주, 짧은 CPU burst | 높은 우선순위 (빨리 처리하고 I/O 대기) |

```
CPU 바운드: 영상 인코딩, 과학 계산, 압축
I/O 바운드: 웹 서버, DB 쿼리, 파일 처리
```

---

## 면접 예상 질문

1. **선점 스케줄링과 비선점 스케줄링의 차이는?**
   - 선점: 강제 전환 가능 / 비선점: 자발적 반납까지 대기

2. **Round Robin의 Time Quantum이 너무 크거나 작으면?**
   - 크면 FCFS, 작으면 컨텍스트 스위칭 오버헤드

3. **기아(Starvation) 현상이란? 해결법은?**
   - 낮은 우선순위가 영원히 실행 못함 → 에이징으로 해결

4. **Convoy Effect란?**
   - FCFS에서 긴 프로세스 뒤에 짧은 프로세스가 오래 대기

5. **실제 OS는 어떤 스케줄링을 사용하나요?**
   - Linux: CFS (Completely Fair Scheduler), 다단계 피드백 큐 변형
