# 데드락 (Deadlock)

## 개념

두 개 이상의 프로세스가 **서로가 가진 자원을 기다리며 무한히 대기**하는 상태.

```
프로세스 A: 자원 1 보유, 자원 2 요청 → 대기
프로세스 B: 자원 2 보유, 자원 1 요청 → 대기

→ 둘 다 영원히 진행 불가
```

### 실생활 비유

```
교차로에서 4방향 차량이 동시에 진입
→ 모두 상대방이 지나가길 기다림
→ 아무도 못 움직임
```

---

## 데드락 발생 조건 4가지 (면접 핵심)

**4가지가 모두 동시에** 성립해야 데드락 발생.

| 조건 | 설명 | 비유 |
|------|------|------|
| **상호 배제 (Mutual Exclusion)** | 자원을 한 번에 하나의 프로세스만 사용 | 프린터는 한 명만 사용 |
| **점유와 대기 (Hold and Wait)** | 자원을 보유한 채로 다른 자원을 기다림 | 포크 하나 쥔 채로 다른 포크 기다림 |
| **비선점 (No Preemption)** | 자원을 강제로 빼앗을 수 없음 | 쓰고 있는 사람에게서 강제로 못 뺏음 |
| **순환 대기 (Circular Wait)** | 자원 대기가 원형으로 형성 | A→B→C→A 순환 |

```
    ┌── A (자원1 보유) ──→ 자원2 요청 ──┐
    │                                    │
    │                                    ↓
    └── 자원1 요청 ←── B (자원2 보유) ──┘

    순환 대기: A → B → A
```

---

## 데드락 처리 방법

### 1. 예방 (Prevention)

4가지 조건 중 **하나를 원천 차단**.

| 조건 | 예방 방법 | 단점 |
|------|----------|------|
| 상호 배제 | 자원을 공유 가능하게 | 불가능한 자원이 많음 |
| 점유와 대기 | 시작 시 필요한 자원을 **모두 한번에** 할당 | 자원 낭비, 기아 가능 |
| 비선점 | 자원을 **강제로 빼앗을 수 있게** | 상태 복원 어려움 |
| 순환 대기 | 자원에 **번호를 부여**, 오름차순으로만 요청 | 유연성 감소 |

**순환 대기 예방이 가장 실용적**.

```
자원 번호: 프린터=1, 디스크=2, 테이프=3

규칙: 작은 번호 → 큰 번호 순서로만 요청
프로세스 A: 프린터(1) 요청 → 디스크(2) 요청 ✅
프로세스 B: 디스크(2) 요청 → 프린터(1) 요청 ❌ (번호 역순 금지)

→ 순환이 형성될 수 없음
```

---

### 2. 회피 (Avoidance)

데드락이 발생할 **가능성이 있으면 자원 할당을 거부**.

#### 은행원 알고리즘 (Banker's Algorithm)

**안전 상태(Safe State)**인 경우에만 자원 할당.

```
시스템 자원: 총 12개

프로세스   최대 요구   현재 할당   추가 필요
  P0          10         5          5
  P1           4         2          2
  P2           9         2          7

가용 자원: 12 - (5+2+2) = 3개

안전 순서 확인:
1. P1 실행 가능 (필요 2 ≤ 가용 3) → 완료 후 반납 → 가용 = 5
2. P0 실행 가능 (필요 5 ≤ 가용 5) → 완료 후 반납 → 가용 = 10
3. P2 실행 가능 (필요 7 ≤ 가용 10) → 완료

안전 순서: P1 → P0 → P2 존재 → 안전 상태 → 할당 허용
```

- 장점: 데드락 방지
- 단점: 최대 자원 요구량을 미리 알아야 함, 오버헤드

---

### 3. 탐지 & 회복 (Detection & Recovery)

데드락을 **허용하되**, 주기적으로 탐지하여 해결.

#### 탐지
- **자원 할당 그래프**: 사이클이 있으면 데드락
- 주기적으로 탐지 알고리즘 실행

#### 회복

| 방법 | 설명 |
|------|------|
| 프로세스 종료 | 데드락 관련 프로세스를 하나씩 종료 |
| 자원 선점 | 프로세스에서 자원을 강제 회수 |
| 체크포인트/롤백 | 이전 상태로 복원 |

---

### 4. 무시 (Ignorance)

데드락을 **무시**. 발생 시 사용자가 직접 해결 (프로세스 종료 등).

- **타조 알고리즘**: 타조가 머리를 모래에 묻듯이 무시
- 대부분의 범용 OS (Linux, Windows)가 채택
- 이유: 데드락 예방/회피의 오버헤드 > 데드락 발생 빈도가 낮음

---

## 처리 방법 비교

| 방법 | 시점 | 오버헤드 | 자원 효율 |
|------|------|---------|----------|
| 예방 | 사전 | 높음 | 낮음 (제약 많음) |
| 회피 | 할당 시 | 중간 | 중간 |
| 탐지 & 회복 | 사후 | 낮음 (탐지 시에만) | 높음 |
| 무시 | - | 없음 | 높음 |

---

## 데드락 vs 라이브락 vs 기아

| 상태 | 설명 |
|------|------|
| **데드락** | 서로의 자원을 기다리며 **영구 대기** |
| **라이브락** | 서로 양보만 반복하며 **진행 못함** (상태는 변함) |
| **기아 (Starvation)** | 우선순위 밀려 **무한 대기** (데드락은 아님) |

```
라이브락 비유:
좁은 복도에서 두 사람이 마주침
→ 왼쪽으로 비킴, 상대도 왼쪽
→ 오른쪽으로 비킴, 상대도 오른쪽
→ 계속 반복... (움직이긴 하지만 진행 안 됨)
```

---

## 실무에서의 데드락

### 데이터베이스 데드락

```sql
-- 트랜잭션 A
UPDATE accounts SET balance = balance - 100 WHERE id = 1;  -- row 1 락
UPDATE accounts SET balance = balance + 100 WHERE id = 2;  -- row 2 대기

-- 트랜잭션 B (동시)
UPDATE accounts SET balance = balance - 50 WHERE id = 2;   -- row 2 락
UPDATE accounts SET balance = balance + 50 WHERE id = 1;   -- row 1 대기

-- 데드락!
```

**해결**:
- 테이블/레코드 접근 순서 통일 (항상 id 오름차순)
- 타임아웃 설정 → 데드락 감지 시 한쪽 롤백
- DB의 데드락 탐지 기능 활용 (MySQL InnoDB)

### Java 데드락

```java
Object lockA = new Object();
Object lockB = new Object();

// 스레드 1
synchronized(lockA) {
    synchronized(lockB) { /* ... */ }
}

// 스레드 2
synchronized(lockB) {
    synchronized(lockA) { /* ... */ }  // 데드락!
}

// 해결: 락 순서 통일
// 스레드 1과 2 모두 lockA → lockB 순서로 획득
```

---

## 면접 예상 질문

1. **데드락이란?**
   - 두 개 이상의 프로세스가 서로의 자원을 기다리며 무한 대기

2. **데드락 발생 조건 4가지는?** (가장 빈출)
   - 상호 배제, 점유와 대기, 비선점, 순환 대기

3. **데드락 해결 방법은?**
   - 예방(조건 차단), 회피(은행원), 탐지&회복, 무시

4. **실제 OS는 어떻게 처리하나요?**
   - 대부분 무시 (타조 알고리즘), 데드락 빈도가 낮으므로

5. **데이터베이스에서 데드락이 발생하면?**
   - 접근 순서 통일, 타임아웃, DB 데드락 탐지 → 한쪽 롤백
