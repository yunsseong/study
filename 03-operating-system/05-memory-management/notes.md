# 메모리 관리

## 메모리 계층 구조

```
         속도 빠름, 용량 작음, 비쌈
              ┌──────┐
              │레지스터│  ← CPU 내부 (1 사이클)
              ├──────┤
              │ 캐시  │  ← L1/L2/L3 (수~수십 사이클)
              ├──────┤
              │ RAM   │  ← 주기억장치 (수백 사이클)
              ├──────┤
              │ SSD   │  ← 보조기억장치
              ├──────┤
              │ HDD   │
              └──────┘
         속도 느림, 용량 큼, 저렴
```

### 왜 계층 구조인가?
- 빠른 메모리는 비쌈 → 모두 빠른 걸로 할 수 없음
- **지역성 원리 (Locality)** 덕분에 캐시가 효과적

---

## 지역성 원리 (Locality)

| 종류 | 설명 | 예시 |
|------|------|------|
| **시간적 지역성** | 최근 접근한 데이터를 곧 다시 접근 | 반복문 변수, 카운터 |
| **공간적 지역성** | 접근한 데이터 근처를 곧 접근 | 배열 순차 접근 |

```c
// 시간적 지역성: sum을 반복 접근
int sum = 0;
for (int i = 0; i < n; i++) {
    sum += arr[i];  // 공간적 지역성: arr 순차 접근
}
```

---

## 주소 바인딩

프로그램의 논리적 주소를 물리적 주소로 변환하는 과정.

| 시점 | 설명 |
|------|------|
| 컴파일 타임 | 물리 주소가 컴파일 시 결정 (고정 위치) |
| 로드 타임 | 메모리 적재 시 결정 (재배치 가능) |
| **실행 타임** | 실행 중에 동적 변환 (**MMU** 사용, 현대 OS) |

### 논리 주소 vs 물리 주소

```
프로세스가 보는 주소 (논리/가상): 0x0000 ~ 0xFFFF
실제 메모리 주소 (물리):          0x5000 ~ 0x5FFF

MMU (Memory Management Unit): 논리 → 물리 변환 (하드웨어)
```

---

## 연속 메모리 할당

프로세스에게 **연속된 메모리 블록**을 할당.

### 할당 전략

| 전략 | 동작 | 특징 |
|------|------|------|
| **First Fit** | 첫 번째 충분한 공간에 할당 | 빠름, 적당한 성능 |
| **Best Fit** | 가장 딱 맞는 공간에 할당 | 외부 단편화 작은 조각 많음 |
| **Worst Fit** | 가장 큰 공간에 할당 | 큰 빈 공간 유지 |

> 일반적으로 First Fit이 가장 효율적

---

## 단편화 (Fragmentation)

### 외부 단편화 (External Fragmentation)

```
메모리: [P1][  빈  ][P2][  빈  ][P3][  빈  ]

총 빈 공간: 300KB
하지만 연속된 공간이 없어서 200KB 프로세스를 할당 못함!
```

- **해결**: 압축(Compaction) - 프로세스를 한쪽으로 모음 (비용 큼)
- **근본 해결**: 페이징 (비연속 할당)

### 내부 단편화 (Internal Fragmentation)

```
페이지 크기: 4KB
프로세스 크기: 14KB

필요 페이지: 4개 (4+4+4+4 = 16KB)
낭비: 16 - 14 = 2KB (내부 단편화)
```

- 할당된 블록 안에서 사용되지 않는 공간
- 페이지 크기가 작을수록 줄어들지만 관리 오버헤드 증가

---

## 페이징 (Paging)

### 개념
- 물리 메모리를 **고정 크기 프레임**으로 분할
- 논리 메모리를 같은 크기의 **페이지**로 분할
- 페이지와 프레임을 **페이지 테이블**로 매핑
- **비연속 할당** → 외부 단편화 해결

```
논리 메모리 (페이지)        물리 메모리 (프레임)
┌─────────┐                ┌─────────┐
│ Page 0  │ ──────────→    │ Frame 3 │
├─────────┤                ├─────────┤
│ Page 1  │ ──────────→    │ Frame 7 │
├─────────┤                ├─────────┤
│ Page 2  │ ──────────→    │ Frame 1 │
├─────────┤                ├─────────┤
│ Page 3  │ ──────────→    │ Frame 5 │
└─────────┘                └─────────┘

페이지 테이블:
Page 0 → Frame 3
Page 1 → Frame 7
Page 2 → Frame 1
Page 3 → Frame 5
```

### 주소 변환

```
논리 주소 = [페이지 번호 | 오프셋]

예: 페이지 크기 4KB, 논리 주소 8196
  페이지 번호 = 8196 / 4096 = 2
  오프셋      = 8196 % 4096 = 4

페이지 테이블: Page 2 → Frame 1
물리 주소 = Frame 1 × 4096 + 4 = 4100
```

### TLB (Translation Lookaside Buffer)

페이지 테이블 접근은 메모리 접근이 필요 → 느림.
**TLB**: 자주 쓰는 페이지 매핑을 캐싱하는 **하드웨어 캐시**.

```
주소 변환 과정:
1. TLB 확인 → 있으면 (TLB Hit) → 바로 물리 주소
2. TLB에 없으면 (TLB Miss) → 페이지 테이블 조회 → TLB에 저장
```

---

## 세그멘테이션 (Segmentation)

프로그램을 **논리적 단위(세그먼트)**로 분할.

```
세그먼트: Code, Data, Stack, Heap 등

세그먼트 테이블:
세그먼트 0 (Code)  → Base: 1000, Limit: 500
세그먼트 1 (Data)  → Base: 2000, Limit: 300
세그먼트 2 (Stack) → Base: 5000, Limit: 400
```

### 페이징 vs 세그멘테이션

| 비교 | 페이징 | 세그멘테이션 |
|------|--------|-------------|
| 분할 단위 | 고정 크기 (프레임) | 가변 크기 (논리 단위) |
| 외부 단편화 | 없음 | 있음 |
| 내부 단편화 | 있음 | 없음 |
| 주소 변환 | 페이지 테이블 | 세그먼트 테이블 |

> 현대 OS는 대부분 **페이징** 사용 (또는 세그멘트 + 페이징 조합)

---

## 면접 예상 질문

1. **내부 단편화와 외부 단편화의 차이는?**
   - 내부: 할당 블록 내 낭비 / 외부: 빈 공간이 흩어져 할당 불가

2. **페이징이란?**
   - 메모리를 고정 크기로 분할, 페이지 테이블로 매핑, 외부 단편화 해결

3. **TLB란?**
   - 페이지 테이블 캐시. 자주 쓰는 매핑을 하드웨어에 저장하여 빠른 주소 변환

4. **페이징과 세그멘테이션의 차이는?**
   - 고정 크기 vs 가변 크기, 외부 단편화 여부

5. **지역성 원리란?**
   - 시간적: 최근 데이터 재접근 / 공간적: 인접 데이터 접근
