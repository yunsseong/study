# 파일 시스템 & I/O

## 파일 시스템 (File System)

### 개념
- 디스크에 데이터를 **체계적으로 저장·관리**하는 시스템
- 파일의 이름, 위치, 권한, 크기 등을 관리

### 파일 시스템 종류

| 파일 시스템 | OS | 특징 |
|-----------|-----|------|
| ext4 | Linux | 저널링, 대용량 지원 |
| NTFS | Windows | 저널링, 권한 관리 |
| APFS | macOS | 암호화, 스냅샷 |
| FAT32 | 범용 | 호환성 좋음, 4GB 파일 제한 |

### 파일 할당 방식

#### 1. 연속 할당
```
파일 A: 블록 3, 4, 5, 6 (연속)
장점: 순차/직접 접근 모두 빠름
단점: 외부 단편화, 파일 크기 변경 어려움
```

#### 2. 연결 할당
```
파일 A: 블록 3 → 블록 7 → 블록 2 → 블록 9 (링크드 리스트)
장점: 외부 단편화 없음
단점: 직접 접근 느림, 포인터 공간 필요
```

#### 3. 인덱스 할당
```
인덱스 블록: [3, 7, 2, 9]  (블록 번호 목록)
파일 A의 데이터: 블록 3, 7, 2, 9

장점: 직접 접근 가능
단점: 인덱스 블록 공간 필요
```

> 현대 파일 시스템은 주로 인덱스 기반 변형 사용

### 디렉토리 구조

```
/ (루트)
├── home/
│   ├── user1/
│   └── user2/
├── etc/        ← 설정 파일
├── var/        ← 로그, 캐시
└── tmp/        ← 임시 파일
```

### inode (Linux)

파일의 **메타데이터를 저장**하는 자료구조. 파일 이름은 포함하지 않음.

| 정보 | 내용 |
|------|------|
| 파일 크기 | 바이트 단위 |
| 소유자/그룹 | UID, GID |
| 권한 | rwx (읽기, 쓰기, 실행) |
| 타임스탬프 | 생성, 수정, 접근 시간 |
| 데이터 블록 포인터 | 실제 데이터 위치 |

```
디렉토리 엔트리: { "hello.txt" → inode 42 }
inode 42: { 크기: 1024, 권한: rw-r--r--, 블록: [5, 12, 33] }
블록 5, 12, 33: 실제 파일 데이터
```

### 저널링 (Journaling)

파일 시스템 변경 사항을 **로그(저널)에 먼저 기록** → 크래시 복구 가능.

```
1. 저널에 변경 예정 내용 기록
2. 실제 파일 시스템에 적용
3. 저널에서 완료 표시

크래시 발생 시: 저널을 보고 미완료 작업을 복구 또는 롤백
```

---

## I/O (입출력)

### 동기 vs 비동기 I/O

| 방식 | 동작 | 특징 |
|------|------|------|
| **동기 (Synchronous)** | I/O 완료까지 대기 | 간단, 블로킹 |
| **비동기 (Asynchronous)** | I/O 요청 후 다른 작업 수행 | 효율적, 논블로킹 |

```
동기 I/O:
프로세스 → read() 요청 → [대기...] → 데이터 수신 → 다음 작업

비동기 I/O:
프로세스 → read() 요청 → 다른 작업 수행 → 콜백으로 데이터 수신
```

### 블로킹 vs 논블로킹

| 방식 | 동작 |
|------|------|
| **블로킹** | 호출한 함수가 완료될 때까지 **제어권을 반환하지 않음** |
| **논블로킹** | 호출 즉시 **제어권 반환**, 완료 여부는 나중에 확인 |

### 조합

| 조합 | 설명 | 예시 |
|------|------|------|
| 동기 + 블로킹 | 요청 후 완료까지 대기 | 일반적인 read() |
| 동기 + 논블로킹 | 요청 후 반복 확인 (폴링) | 바쁜 대기 |
| **비동기 + 논블로킹** | 요청 후 다른 작업, 완료 시 알림 | Node.js, epoll, IOCP |
| 비동기 + 블로킹 | 거의 사용 안 함 | - |

```
# 비동기 + 논블로킹이 가장 효율적 (이벤트 기반)

요청 1 → 커널에 전달, 바로 복귀
요청 2 → 커널에 전달, 바로 복귀
요청 3 → 커널에 전달, 바로 복귀

... 다른 작업 수행 ...

← 요청 2 완료 알림 (콜백)
← 요청 1 완료 알림 (콜백)
← 요청 3 완료 알림 (콜백)
```

---

### I/O 멀티플렉싱

하나의 스레드로 **여러 I/O를 감시**하는 기법.

| 방식 | 특징 |
|------|------|
| **select** | 초기 모델, FD 수 제한 (1024), 매번 전체 순회 |
| **poll** | FD 제한 없음, 여전히 전체 순회 |
| **epoll** (Linux) | 이벤트 기반, 변경된 FD만 알림 → **고성능** |
| **kqueue** (macOS) | epoll과 유사 |

```
epoll 동작:
1. 감시할 소켓(FD)을 등록
2. 이벤트 발생 시에만 알림 (O(1))
3. 수만 개의 동시 연결 처리 가능

→ Nginx, Node.js, Netty(Spring WebFlux)의 핵심 원리
```

---

## 디스크 스케줄링

디스크 헤드의 이동을 최소화하여 I/O 성능 향상.

### 주요 알고리즘

| 알고리즘 | 동작 | 특징 |
|---------|------|------|
| FCFS | 요청 순서대로 | 간단, 비효율 |
| **SSTF** | 현재 위치에서 가장 가까운 요청 | 효율적, 기아 가능 |
| **SCAN (엘리베이터)** | 한 방향으로 끝까지 갔다가 반대로 | 공정, 효율적 |
| C-SCAN | 한 방향으로만, 끝에서 처음으로 점프 | 더 공정 |

```
SCAN (엘리베이터) 예시:
요청: 98, 183, 37, 122, 14, 124, 65, 67
현재 위치: 53, 오른쪽으로 이동 중

이동: 53 → 65 → 67 → 98 → 122 → 124 → 183 → (끝) → 37 → 14
```

---

## 백엔드 관련 I/O 지식

### Java I/O 모델

| 방식 | 설명 | 사용 |
|------|------|------|
| BIO (Blocking I/O) | 요청당 스레드 1개 | 전통적 Spring MVC |
| NIO (Non-blocking I/O) | 셀렉터 + 채널 | Netty |
| AIO (Async I/O) | 완전 비동기 | 비교적 덜 사용 |

### Spring MVC vs WebFlux

```
Spring MVC (BIO):
- 요청마다 스레드 할당
- 동기 + 블로킹
- 간단하고 직관적

Spring WebFlux (NIO):
- 적은 스레드로 많은 요청 처리
- 비동기 + 논블로킹 (Reactor 패턴)
- 높은 동시성 (I/O 바운드)
```

### FastAPI의 I/O 모델

```python
# 비동기 (논블로킹) - I/O 바운드에 적합
@app.get("/users")
async def get_users():
    users = await db.fetch_all()  # 비동기 DB 조회
    return users

# 동기 (블로킹) - CPU 바운드에 적합
@app.get("/compute")
def compute():
    result = heavy_computation()  # 별도 스레드풀에서 실행
    return result
```

---

## 면접 예상 질문

1. **동기/비동기, 블로킹/논블로킹의 차이는?**
   - 동기/비동기: 작업 완료 확인 방식 / 블로킹/논블로킹: 제어권 반환 여부

2. **epoll이란?**
   - 이벤트 기반 I/O 멀티플렉싱, 변경된 FD만 알림, 고성능

3. **inode란?**
   - 파일의 메타데이터를 저장하는 자료구조 (이름 제외)

4. **저널링이란?**
   - 변경 사항을 로그에 먼저 기록하여 크래시 시 복구 가능

5. **Spring MVC와 WebFlux의 차이는?**
   - MVC: 동기+블로킹, 요청당 스레드 / WebFlux: 비동기+논블로킹, 적은 스레드

6. **디스크 스케줄링이 필요한 이유는?**
   - 디스크 헤드 이동 최소화 → I/O 성능 향상
