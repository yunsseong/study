# 인덱스 (Index)

## 개념

- 데이터를 **빠르게 찾기 위한** 자료구조 (책의 색인과 같음)
- 인덱스 없이 조회 → **Full Table Scan** (처음부터 끝까지 다 봄)
- 인덱스 있으면 → **Index Scan** (필요한 데이터만 빠르게 접근)

```
인덱스 없이:  100만 행 전부 확인 → O(n)
인덱스 있으면: B-Tree로 탐색     → O(log n)

100만 행 기준: Full Scan ~100만 번 vs Index ~20번
```

---

## B-Tree (면접 핵심)

MySQL InnoDB의 기본 인덱스 구조.

### 구조

```
                    [30 | 60]                    ← 루트 노드
                   /    |    \
           [10|20]   [40|50]   [70|80]           ← 내부 노드
           / | \     / | \     / | \
         [1~9][11~19][21~29]...                  ← 리프 노드 (실제 데이터 포인터)
```

### 왜 B-Tree인가? (면접 빈출)

```
이진 탐색 트리: 높이가 클 수 있음 (최악 O(n))
해시: 범위 검색 불가 (=만 가능, >, <, BETWEEN 불가)
B-Tree: 균형 유지 + 범위 검색 가능 + 디스크 접근 최소화

B-Tree가 디스크에 유리한 이유:
- 하나의 노드에 여러 키를 저장 → 디스크 읽기 횟수 감소
- 높이가 낮음 → 4단계 정도면 수천만 행 탐색 가능
```

### B-Tree vs B+Tree

| 비교 | B-Tree | B+Tree |
|------|--------|--------|
| 데이터 위치 | 모든 노드 | **리프 노드만** |
| 리프 연결 | 없음 | **연결 리스트** (범위 스캔 유리) |
| 사용 | 일반적 | **MySQL InnoDB** (실제 사용) |

```
B+Tree 리프 노드:
[1,2,3] ←→ [4,5,6] ←→ [7,8,9] ←→ [10,11,12]

범위 검색 (WHERE age BETWEEN 4 AND 9):
→ 리프에서 4를 찾고, 연결 리스트를 따라 9까지 순차 스캔
→ 매우 빠름
```

---

## 인덱스 종류

### 클러스터형 인덱스 vs 비클러스터형 인덱스

| 비교 | 클러스터형 (Clustered) | 비클러스터형 (Non-clustered) |
|------|----------------------|---------------------------|
| 데이터 정렬 | 인덱스 순서로 **물리적 정렬** | 별도 인덱스 구조, 포인터로 연결 |
| 개수 | 테이블당 **1개** | 테이블당 **여러 개** |
| 예시 | **PRIMARY KEY** | CREATE INDEX로 만든 인덱스 |
| 속도 | 범위 스캔 매우 빠름 | 약간 느림 (포인터 추가 탐색) |

```
클러스터형 (PK = id):
실제 데이터가 id 순으로 저장됨
[id=1, data] → [id=2, data] → [id=3, data]

비클러스터형 (email 인덱스):
인덱스: [alice@... → id=3] → [bob@... → id=1] → [carol@... → id=2]
                    ↓                 ↓                  ↓
           실제 데이터 위치     실제 데이터 위치     실제 데이터 위치
```

---

## 인덱스 생성과 사용

```sql
-- 단일 컬럼 인덱스
CREATE INDEX idx_users_email ON users (email);

-- 복합 인덱스 (여러 컬럼)
CREATE INDEX idx_posts_author_created ON posts (author_id, created_at);

-- UNIQUE 인덱스
CREATE UNIQUE INDEX idx_users_email_unique ON users (email);

-- 인덱스 확인
SHOW INDEX FROM users;

-- 인덱스 삭제
DROP INDEX idx_users_email ON users;
```

### 어떤 컬럼에 인덱스를 걸어야 하나?

```
✅ 걸어야 하는 경우:
├── WHERE 절에 자주 사용되는 컬럼
├── JOIN 조건 컬럼 (FK)
├── ORDER BY 컬럼
├── 카디널리티가 높은 컬럼 (값의 종류가 많음: email, id)
└── 자주 조회하지만 수정이 적은 컬럼

❌ 걸지 않아야 하는 경우:
├── 카디널리티가 낮은 컬럼 (성별: M/F, 불리언: Y/N)
├── 데이터가 매우 적은 테이블
├── INSERT/UPDATE/DELETE가 빈번한 컬럼
└── 거의 조회에 사용되지 않는 컬럼
```

### 카디널리티 (Cardinality)

```
높은 카디널리티 (인덱스 효과 좋음):
  email: alice@..., bob@..., carol@... → 값이 거의 유니크

낮은 카디널리티 (인덱스 효과 낮음):
  gender: M, F → 값이 2종류뿐 → 절반을 읽어야 해서 Full Scan과 비슷
```

---

## 복합 인덱스와 최좌선 원칙

### 복합 인덱스

```sql
CREATE INDEX idx_abc ON table (a, b, c);
```

이 인덱스가 적용되는 쿼리:

```sql
WHERE a = 1                      -- ✅ a 사용
WHERE a = 1 AND b = 2            -- ✅ a, b 사용
WHERE a = 1 AND b = 2 AND c = 3  -- ✅ a, b, c 모두 사용
WHERE a = 1 AND c = 3            -- ⚠️ a만 사용 (b를 건너뜀)
WHERE b = 2                      -- ❌ 인덱스 미사용 (a가 없음)
WHERE b = 2 AND c = 3            -- ❌ 인덱스 미사용
```

**최좌선 원칙 (Leftmost Prefix)**: 복합 인덱스는 **왼쪽 컬럼부터 순서대로** 사용해야 함.

```
인덱스 (a, b, c)는 전화번호부와 같음:
1. 성(a)으로 먼저 정렬
2. 같은 성 안에서 이름(b)으로 정렬
3. 같은 이름 안에서 별명(c)으로 정렬

→ 이름(b)만 알면 전화번호부 처음부터 다 봐야 함
→ 성(a)을 알아야 빠르게 찾을 수 있음
```

---

## 인덱스가 안 타는 경우

```sql
-- 1. 컬럼에 함수/연산을 사용
WHERE YEAR(created_at) = 2025          -- ❌ 함수 적용
WHERE created_at >= '2025-01-01'       -- ✅ 범위 검색

-- 2. 타입이 불일치
WHERE phone = 01012345678              -- ❌ 숫자 (phone이 VARCHAR이면)
WHERE phone = '01012345678'            -- ✅ 문자열

-- 3. LIKE 앞에 %
WHERE name LIKE '%John'                -- ❌ 앞에 와일드카드
WHERE name LIKE 'John%'                -- ✅ 뒤에 와일드카드

-- 4. OR 조건 (일부 경우)
WHERE a = 1 OR b = 2                   -- ⚠️ 각각 인덱스 필요

-- 5. NOT, != 조건
WHERE status != 'DELETED'             -- ⚠️ 풀스캔 가능
```

---

## 커버링 인덱스 (Covering Index)

쿼리에 필요한 모든 컬럼이 인덱스에 포함되어, **테이블 접근 없이 인덱스만으로 조회**.

```sql
-- 인덱스: (author_id, created_at)
SELECT author_id, created_at FROM posts WHERE author_id = 1;
-- → 인덱스만 읽으면 됨 (테이블 안 봐도 됨) → 매우 빠름

SELECT * FROM posts WHERE author_id = 1;
-- → 인덱스로 찾고 + 테이블에서 나머지 컬럼 읽기 → 추가 비용
```

---

## 인덱스의 비용

```
인덱스는 공짜가 아니다!

읽기 성능: ↑ 향상
쓰기 성능: ↓ 저하 (INSERT/UPDATE/DELETE마다 인덱스도 갱신)
저장 공간: ↑ 추가 사용

∴ 필요한 인덱스만 만들어야 함
```

---

## 면접 예상 질문

1. **인덱스가 왜 빠른가요? (B-Tree 구조로 설명)**
   - B+Tree 구조로 O(log n) 탐색, 디스크 접근 최소화, 범위 검색은 리프 노드 연결 리스트

2. **인덱스를 걸면 항상 빨라지나요?**
   - No. 쓰기 성능 저하, 카디널리티 낮으면 효과 없음

3. **복합 인덱스에서 최좌선 원칙이란?**
   - 왼쪽 컬럼부터 순서대로 사용해야 인덱스 적용

4. **클러스터형 인덱스와 비클러스터형 인덱스의 차이는?**
   - 클러스터형: 데이터 물리 정렬, 테이블당 1개 / 비클러스터형: 별도 구조, 여러 개

5. **인덱스가 안 타는 경우는?**
   - 컬럼에 함수, 타입 불일치, LIKE 앞에 %, 최좌선 원칙 위반

6. **커버링 인덱스란?**
   - 인덱스만으로 조회 완료, 테이블 접근 불필요
