# 가상 메모리 (Virtual Memory)

## 개념

- 물리 메모리보다 **큰 프로세스**도 실행 가능하게 하는 기법
- 프로세스 전체를 메모리에 올리지 않고, **필요한 페이지만** 적재
- 디스크를 메모리의 확장처럼 활용

```
가상 주소 공간 (프로세스 시점): 4GB
물리 메모리 (실제 RAM):         2GB
디스크 (스왑 영역):              보조 저장소

→ 자주 쓰는 페이지는 RAM에, 안 쓰는 페이지는 디스크에
```

---

## 요구 페이징 (Demand Paging)

**필요할 때만** 페이지를 메모리에 적재.

### 동작 원리

```
페이지 테이블:
Page 0 → Frame 3   (valid)     ← 메모리에 있음
Page 1 → 디스크     (invalid)   ← 메모리에 없음
Page 2 → Frame 1   (valid)
Page 3 → 디스크     (invalid)
```

### 페이지 폴트 (Page Fault)

접근하려는 페이지가 메모리에 없을 때 발생.

```
① CPU가 Page 1 접근 시도
② 페이지 테이블 확인 → invalid (메모리에 없음)
③ 페이지 폴트 발생 (트랩)
④ OS가 디스크에서 해당 페이지를 찾음
⑤ 빈 프레임에 페이지 적재
   (빈 프레임 없으면 → 페이지 교체 알고리즘)
⑥ 페이지 테이블 업데이트 (valid로 변경)
⑦ 중단됐던 명령어 재실행
```

```
         CPU
          │
    ① 페이지 접근
          ↓
     페이지 테이블
          │
    ② invalid?──→ ③ 페이지 폴트
          │              │
    valid │         ④ 디스크에서 읽기
          ↓              │
     물리 메모리 ←── ⑤ 프레임에 적재
          │
    ⑦ 명령어 재실행
```

---

## 페이지 교체 알고리즘

메모리가 가득 찼을 때 **어떤 페이지를 내보낼지** 결정.

목표: **페이지 폴트를 최소화**

### 1. FIFO (First In First Out)

**가장 먼저 들어온** 페이지를 교체.

```
참조 열: 1, 2, 3, 4, 1, 2, 5, 1, 2, 3, 4, 5
프레임 수: 3

1: [1]         → 폴트
2: [1,2]       → 폴트
3: [1,2,3]     → 폴트
4: [4,2,3]     → 폴트 (1 교체)
1: [4,1,3]     → 폴트 (2 교체)
2: [4,1,2]     → 폴트 (3 교체)
5: [5,1,2]     → 폴트 (4 교체)
1: [5,1,2]     → 히트
2: [5,1,2]     → 히트
3: [3,1,2]     → 폴트 (5 교체)  ← ❓ 실은 [5,3,2]가 아니라..

총 페이지 폴트: 9
```

- 장점: 구현 간단
- 단점: **Belady's Anomaly** (프레임 수 늘려도 폴트 증가 가능)

---

### 2. OPT (Optimal)

**앞으로 가장 오래 사용되지 않을** 페이지를 교체. (이론적 최적)

```
참조 열: 1, 2, 3, 4, 1, 2, 5, 1, 2, 3, 4, 5
프레임 수: 3

4 적재 시: [1,2,3] 중 누구를 교체?
→ 1은 곧 사용됨, 2도 곧 사용됨, 3은 나중에 사용
→ 3을 교체: [1,2,4]

총 페이지 폴트: 7 (최소)
```

- 장점: 최적 (비교 기준)
- 단점: **미래를 알 수 없음** → 실제 구현 불가, 비교용으로만 사용

---

### 3. LRU (Least Recently Used)

**가장 오래 전에 사용된** 페이지를 교체. 가장 널리 사용.

```
참조 열: 1, 2, 3, 4, 1, 2, 5, 1, 2, 3, 4, 5
프레임 수: 3

1: [1]           → 폴트
2: [1,2]         → 폴트
3: [1,2,3]       → 폴트
4: [4,2,3]       → 폴트 (1이 가장 오래됨 → 교체)
1: [4,1,3]       → 폴트 (2가 가장 오래됨 → 교체)
2: [4,1,2]       → 폴트 (3이 가장 오래됨 → 교체)
5: [5,1,2]       → 폴트 (4가 가장 오래됨 → 교체)
1: [5,1,2]       → 히트 (1의 사용 시간 갱신)
2: [5,1,2]       → 히트 (2의 사용 시간 갱신)
3: [3,1,2]       → 폴트 (5가 가장 오래됨 → 교체)
4: [3,4,2]       → 폴트 (1이 가장 오래됨 → 교체)
5: [3,4,5]       → 폴트 (2가 가장 오래됨 → 교체)

총 페이지 폴트: 10
```

- 장점: OPT에 근접한 성능, Belady's Anomaly 없음
- 단점: 구현 비용 (사용 시간 추적 필요)

### LRU 근사 알고리즘

| 알고리즘 | 방법 |
|---------|------|
| 참조 비트 | 접근 시 비트=1, 주기적으로 초기화. 비트=0인 페이지 교체 |
| Clock (Second Chance) | 원형 큐로 순회, 참조 비트=1이면 0으로 바꾸고 넘어감, 0이면 교체 |

#### Clock 알고리즘

```
    ┌→ [A, ref=1] → [B, ref=0] → [C, ref=1] → [D, ref=0] ─┐
    └───────────────────────────────────────────────────────┘
                    ↑ 포인터

교체 시:
1. 포인터 위치의 ref 비트 확인
2. ref=1 → 0으로 변경, 다음으로 이동 (한 번 기회를 줌)
3. ref=0 → 이 페이지 교체!
```

---

### 알고리즘 비교

| 알고리즘 | 성능 | 구현 | Belady's Anomaly |
|---------|------|------|-----------------|
| FIFO | 나쁨 | 간단 | 있음 |
| **OPT** | 최적 | 불가능 | 없음 |
| **LRU** | 좋음 | 비쌈 | 없음 |
| Clock | 준수 | 적당 | 없음 |

---

## 스래싱 (Thrashing)

### 개념
페이지 폴트가 과도하게 발생하여 **CPU가 실제 작업 대신 페이지 교체만** 하는 상태.

```
멀티프로그래밍 정도 증가
→ 각 프로세스의 메모리 부족
→ 페이지 폴트 급증
→ 디스크 I/O 폭증
→ CPU 이용률 급감
→ OS: "CPU가 놀고 있네" → 프로세스 더 투입
→ 더 악화 (악순환)
```

```
CPU 이용률
    ↑
    |      /\
    |     /  \
    |    /    \
    |   /      \____  ← 스래싱 발생
    |  /
    | /
    +──────────────→ 멀티프로그래밍 정도
```

### 해결법

| 방법 | 설명 |
|------|------|
| **워킹 셋 모델** | 프로세스가 일정 시간 동안 참조하는 페이지 집합(워킹 셋)만큼 메모리 보장 |
| **PFF (Page Fault Frequency)** | 페이지 폴트 비율 상한/하한 설정 → 초과 시 프레임 추가, 미만 시 회수 |
| 프로세스 수 조절 | 멀티프로그래밍 정도를 줄임 (일부 프로세스를 디스크로 스왑 아웃) |

---

## 스왑 (Swap)

메모리 부족 시 프로세스 전체 또는 페이지를 **디스크의 스왑 영역**으로 이동.

```
Swap Out: 메모리 → 디스크 (메모리 확보)
Swap In:  디스크 → 메모리 (다시 실행)
```

- Linux: 스왑 파티션 또는 스왑 파일
- 스왑이 많이 발생하면 → 성능 저하 → 메모리 증설 필요

---

## 면접 예상 질문

1. **가상 메모리란?**
   - 물리 메모리보다 큰 프로세스도 실행 가능하게 하는 기법, 필요한 페이지만 적재

2. **페이지 폴트란?**
   - 접근하려는 페이지가 메모리에 없을 때 발생, 디스크에서 가져와야 함

3. **LRU 페이지 교체 알고리즘이란?**
   - 가장 오래 전에 사용된 페이지를 교체, OPT에 근접한 성능

4. **FIFO vs LRU 차이는?**
   - FIFO: 들어온 순서 / LRU: 사용된 순서, LRU가 성능 좋음

5. **스래싱이란? 해결법은?**
   - 페이지 폴트 과다로 CPU가 교체만 함 → 워킹 셋, PFF, 프로세스 수 조절

6. **Belady's Anomaly란?**
   - FIFO에서 프레임 수를 늘려도 페이지 폴트가 증가하는 현상
