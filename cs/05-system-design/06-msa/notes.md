# 마이크로서비스 아키텍처 (MSA)

## 모놀리식 vs MSA

### 모놀리식 (Monolithic)

```
하나의 애플리케이션에 모든 기능이 포함.

[하나의 서버]
├── 유저 모듈
├── 주문 모듈
├── 결제 모듈
├── 알림 모듈
└── 하나의 DB

장점: 개발 단순, 배포 단순, 디버깅 쉬움, 트랜잭션 관리 용이
단점: 커지면 복잡, 부분 배포 불가, 기술 스택 통일 필요, 장애 전파
```

### 마이크로서비스 (Microservices)

```
기능별로 독립된 서비스로 분리.

[유저 서비스]   ← 자체 DB
[주문 서비스]   ← 자체 DB
[결제 서비스]   ← 자체 DB
[알림 서비스]   ← 자체 DB

각 서비스가 독립적으로 배포, 확장, 기술 선택 가능.
서비스 간 통신: HTTP(REST), gRPC, 메시지 큐
```

### 비교

| 비교 | 모놀리식 | MSA |
|------|---------|-----|
| 배포 | 전체 배포 | 서비스별 독립 배포 |
| 확장 | 전체 스케일링 | 서비스별 스케일링 |
| 기술 | 단일 스택 | 서비스별 다른 스택 가능 |
| 장애 | 전체 장애 가능 | 장애 격리 (해당 서비스만) |
| 복잡도 | 코드 복잡 | 인프라/운영 복잡 |
| DB | 하나의 DB | 서비스별 DB (분산 트랜잭션 어려움) |
| 적합 | 초기 스타트업, 소규모 | 대규모, 팀이 많은 조직 |

---

## 서비스 간 통신

### 동기 통신

```
1. REST API (HTTP)
   주문서비스 → GET /api/users/1 → 유저서비스

   장점: 단순, 직관적
   단점: 서비스 간 결합도 높음, 호출 체인 → 지연 누적

2. gRPC
   Protocol Buffers 기반, 바이너리 통신

   장점: 빠름 (HTTP/2, 바이너리), 양방향 스트리밍
   단점: 디버깅 어려움, 브라우저 직접 호출 불가
   사용: 서비스 내부 통신, 고성능 필요 시
```

### 비동기 통신

```
메시지 큐/이벤트를 통한 비동기 통신.

주문서비스 → [Kafka: order-created] → 결제서비스
                                    → 재고서비스
                                    → 알림서비스

장점: 결합도 낮음, 장애 전파 방지, 확장 유연
단점: 복잡도 증가, 디버깅 어려움, 최종 일관성
```

### 통신 패턴 선택

```
즉시 응답 필요      → 동기 (REST, gRPC)
응답 불필요 / 느려도 됨 → 비동기 (메시지 큐)
내부 고성능 통신    → gRPC
이벤트 전파         → Kafka (이벤트 드리븐)
```

---

## API Gateway

```
클라이언트와 내부 서비스 사이의 진입점.

클라이언트 → [API Gateway] → 유저 서비스
                           → 주문 서비스
                           → 결제 서비스

역할:
├── 라우팅: /api/users → 유저 서비스, /api/orders → 주문 서비스
├── 인증/인가: JWT 검증을 게이트웨이에서 처리
├── Rate Limiting: 요청 수 제한
├── 로드 밸런싱: 서비스 인스턴스로 분산
├── 응답 캐싱: 자주 요청되는 데이터 캐싱
└── 로깅/모니터링: 요청/응답 로그

대표: Kong, AWS API Gateway, Spring Cloud Gateway, Nginx
```

---

## 서비스 디스커버리 (Service Discovery)

```
문제: 서비스가 여러 대일 때 IP/포트가 동적으로 변함 → 어떻게 찾나?

해결: 서비스 레지스트리에 등록/조회

1. 서비스 시작 → 레지스트리에 등록 ("나는 유저서비스, IP 10.0.0.1:8080")
2. 다른 서비스가 호출 시 → 레지스트리에 조회 ("유저서비스 어디야?")
3. 레지스트리 → "10.0.0.1:8080, 10.0.0.2:8080" 응답
4. 호출 서비스가 선택하여 요청

방식:
├── 클라이언트 사이드: 호출자가 레지스트리에서 직접 조회 (Eureka)
└── 서버 사이드: LB가 레지스트리 조회 후 라우팅 (AWS ELB)

대표: Eureka (Spring Cloud), Consul, etcd, Kubernetes DNS
```

---

## 서킷 브레이커 (Circuit Breaker)

```
외부 서비스 장애가 전체로 전파되는 것을 방지.

전기 회로의 차단기(Circuit Breaker)와 같은 원리.

상태:
1. CLOSED (정상): 요청을 그대로 전달
   실패 횟수 카운트 → 임계치 초과 시 OPEN

2. OPEN (차단): 요청을 차단, 즉시 에러 응답 (빠른 실패)
   서비스 호출하지 않음 → 장애 서비스에 부하 안 줌
   일정 시간 후 HALF-OPEN

3. HALF-OPEN (시험): 일부 요청만 전달하여 회복 확인
   성공 → CLOSED로 복귀
   실패 → OPEN으로 유지
```

```
시나리오:
  주문서비스 → 결제서비스 (장애!)

서킷 브레이커 없으면:
  주문서비스도 응답 지연 → 커넥션 풀 소진 → 주문서비스도 장애 (연쇄 장애)

서킷 브레이커 있으면:
  결제서비스 실패 감지 → 회로 OPEN → 즉시 에러 응답 (빠른 실패)
  → 주문서비스는 정상 동작 유지, 결제만 일시 불가
```

```java
// Spring Cloud + Resilience4j
@Service
public class PaymentService {

    @CircuitBreaker(name = "paymentService", fallbackMethod = "paymentFallback")
    public PaymentResult pay(OrderDto order) {
        return paymentClient.requestPayment(order);
    }

    // 서킷 브레이커 발동 시 대체 로직
    public PaymentResult paymentFallback(OrderDto order, Exception e) {
        return PaymentResult.pending("결제 서비스 일시 불가, 잠시 후 재시도해주세요");
    }
}
```

---

## 분산 트랜잭션

### 문제

```
모놀리식: 하나의 DB → @Transactional로 해결
MSA: 서비스별 DB → 하나의 트랜잭션으로 묶기 어려움

주문 생성(주문DB) + 결제(결제DB) + 재고 감소(재고DB)
→ 하나라도 실패하면 전부 롤백해야 함
```

### SAGA 패턴

```
분산 트랜잭션을 각 서비스의 로컬 트랜잭션 + 보상 트랜잭션으로 관리.

성공 흐름:
  주문 생성 → 결제 처리 → 재고 감소 → 완료

실패 흐름 (재고 부족):
  주문 생성 → 결제 처리 → 재고 감소 실패!
  → 결제 취소 (보상) → 주문 취소 (보상)
```

```
Choreography (이벤트 기반):
  각 서비스가 이벤트를 발행하고, 다음 서비스가 구독
  주문서비스 → [order-created] → 결제서비스
  결제서비스 → [payment-completed] → 재고서비스
  재고서비스 → [stock-decreased] → 완료

  장점: 결합도 낮음
  단점: 흐름 파악 어려움, 디버깅 어려움

Orchestration (중앙 조정자):
  SAGA 오케스트레이터가 전체 흐름 관리
  오케스트레이터 → 주문서비스.생성()
  오케스트레이터 → 결제서비스.결제()
  오케스트레이터 → 재고서비스.감소()
  실패 시 → 보상 트랜잭션 호출

  장점: 흐름 명확, 관리 쉬움
  단점: 오케스트레이터가 단일 장애점
```

---

## MSA 도입 가이드

```
MSA를 도입해야 하는 신호:
├── 팀이 커져서 하나의 코드베이스 관리가 힘듦
├── 배포 주기가 서비스마다 다름
├── 특정 기능만 확장해야 함 (검색만 트래픽 많음)
├── 기술 스택을 다르게 가져가고 싶음
└── 모놀리식의 장애가 전체에 영향을 줌

MSA가 필요 없는 경우:
├── 소규모 팀 (5명 이하)
├── 초기 스타트업 (빠른 출시가 우선)
├── 단순한 CRUD 서비스
└── 운영 인력이 부족
```

---

## 면접 예상 질문

1. **모놀리식과 MSA의 차이는?**
   - 모놀리식: 하나의 앱, 단순 / MSA: 독립 서비스, 유연하지만 복잡

2. **서킷 브레이커란?**
   - 장애 서비스로의 요청을 차단하여 연쇄 장애 방지, CLOSED→OPEN→HALF-OPEN

3. **MSA에서 분산 트랜잭션은 어떻게 처리하나요?**
   - SAGA 패턴 (Choreography / Orchestration)

4. **서비스 디스커버리란?**
   - 동적으로 변하는 서비스 위치를 레지스트리에서 조회

5. **API Gateway의 역할은?**
   - 라우팅, 인증, Rate Limiting, 로드 밸런싱, 로깅
