# SQL 기본 문법과 JOIN 면접 질문 + 답변

## 기본 개념 (1~5)

**Q1.** SQL의 실행 순서를 설명해주세요. 작성 순서와 어떻게 다른가요?

> SQL의 작성 순서는 SELECT, FROM, WHERE, GROUP BY, HAVING, ORDER BY, LIMIT이지만, 실제 실행 순서는 FROM(1) -> WHERE(2) -> GROUP BY(3) -> HAVING(4) -> SELECT(5) -> ORDER BY(6) -> LIMIT(7)입니다. FROM에서 테이블을 가져온 뒤 WHERE로 행을 필터링하고, GROUP BY로 그룹화한 뒤 HAVING으로 그룹 조건을 적용합니다. 이후 SELECT에서 컬럼을 선택하고 ORDER BY로 정렬, LIMIT으로 개수를 제한합니다. 이 순서를 알아야 WHERE에서 별칭을 못 쓰는 이유, HAVING에서 집계 함수를 쓸 수 있는 이유 등을 이해할 수 있습니다.

**Q2.** WHERE 절에서 SELECT에서 정의한 별칭(alias)을 사용할 수 없는 이유는 무엇인가요?

> SQL의 실행 순서에서 WHERE는 2번째, SELECT는 5번째로 실행되기 때문입니다. WHERE가 실행되는 시점에는 아직 SELECT가 처리되지 않았으므로, SELECT에서 정의한 별칭이 존재하지 않습니다. 반면 ORDER BY는 SELECT 이후에 실행되므로 별칭을 사용할 수 있습니다.

**Q3.** INNER JOIN이 무엇이고, 어떤 결과를 반환하나요?

> INNER JOIN은 양쪽 테이블에 모두 일치하는 행만 반환하는 JOIN입니다. 교집합과 비슷한 개념으로, JOIN 조건에 맞는 행만 결과에 포함됩니다. 예를 들어 employees 테이블과 departments 테이블을 dept_id로 INNER JOIN하면, 부서가 지정되지 않은 직원이나 소속 직원이 없는 부서는 결과에서 제외됩니다. 가장 기본적이고 많이 사용되는 JOIN 방식입니다.

**Q4.** LEFT JOIN은 어떤 상황에서 사용하나요? INNER JOIN과의 차이를 설명해주세요.

> LEFT JOIN은 왼쪽 테이블의 모든 행을 반환하고, 오른쪽 테이블에 일치하는 값이 없으면 NULL로 채웁니다. INNER JOIN은 양쪽 모두 일치하는 행만 반환하므로, 일치하지 않는 행은 결과에서 제외됩니다. 실무에서는 "부서가 없는 직원도 포함해서 보여줘"처럼 연관 데이터가 없는 경우도 포함해야 할 때 LEFT JOIN을 사용합니다. OUTER JOIN 중에서 가장 많이 사용되는 방식입니다.

**Q5.** CROSS JOIN과 SELF JOIN은 각각 무엇이며, 실무에서 어떤 경우에 사용하나요?

> CROSS JOIN은 조건 없이 두 테이블의 모든 행을 조합하는 카르테시안 곱입니다. A 테이블이 4행, B 테이블이 3행이면 결과는 12행이 됩니다. 실무에서는 모든 상품과 모든 색상의 조합 테이블을 만들 때 등 의도적으로 사용하는 경우가 드물고, JOIN 조건을 빠뜨렸을 때 실수로 발생하는 경우가 더 많습니다. SELF JOIN은 같은 테이블을 두 번 사용하는 JOIN으로, 계층 구조(상사-부하 관계)를 조회할 때 자주 사용합니다. 예를 들어 employees 테이블에서 manager_id를 이용해 직원과 상사 이름을 함께 조회할 수 있습니다.

## 비교/구분 (6~9)

**Q6.** WHERE와 HAVING의 차이를 설명해주세요. 성능 관점에서 어떤 것을 먼저 사용해야 하나요?

> WHERE는 GROUP BY 이전에 실행되어 개별 행을 필터링하고, HAVING은 GROUP BY 이후에 실행되어 그룹을 필터링합니다. WHERE에서는 집계 함수를 사용할 수 없지만, HAVING에서는 사용할 수 있습니다. 성능 관점에서는 가능한 한 WHERE로 먼저 행을 걸러내는 것이 유리합니다. 행 수를 줄인 뒤 GROUP BY를 하면 그룹화 대상이 줄어들어 처리 비용이 감소하기 때문입니다.

**Q7.** 서브쿼리와 JOIN의 성능 차이는 무엇인가요? 대부분의 경우 어느 쪽이 유리한가요?

> 대부분의 경우 JOIN이 성능에 유리합니다. JOIN은 옵티마이저가 실행 계획을 최적화하기 쉽고, JOIN 키에 인덱스를 효과적으로 활용할 수 있습니다. 서브쿼리는 내부 쿼리를 먼저 실행한 뒤 외부에서 비교하는 방식이라 대량 데이터에서 느릴 수 있습니다. 특히 상관 서브쿼리는 외부 행마다 내부 쿼리가 반복 실행되므로 매우 비효율적입니다. 다만 MySQL 옵티마이저가 서브쿼리를 JOIN으로 자동 변환하는 경우도 있으므로, EXPLAIN으로 실행 계획을 확인하는 것이 중요합니다.

**Q8.** 상관 서브쿼리(Correlated Subquery)와 일반 서브쿼리의 차이점은 무엇인가요?

> 일반 서브쿼리는 내부 쿼리가 독립적으로 한 번 실행되어 결과 집합을 만들고, 외부 쿼리에서 그 결과를 사용합니다. 반면 상관 서브쿼리는 내부 쿼리가 외부 테이블의 값을 참조하므로, 외부 쿼리의 각 행마다 내부 쿼리가 반복 실행됩니다. 예를 들어 EXISTS 절에서 외부 테이블의 컬럼을 참조하는 경우가 상관 서브쿼리입니다. 외부 행이 N개이면 내부 쿼리도 N번 실행되므로 성능이 매우 느릴 수 있습니다.

**Q9.** LEFT JOIN과 RIGHT JOIN의 차이점은 무엇인가요? 실무에서는 어느 쪽을 더 많이 사용하나요?

> LEFT JOIN은 왼쪽 테이블의 모든 행을 반환하고 오른쪽에 일치하는 값이 없으면 NULL로 채우며, RIGHT JOIN은 그 반대로 오른쪽 테이블의 모든 행을 반환합니다. 기능적으로는 테이블 순서만 바꾸면 동일한 결과를 얻을 수 있습니다. 실무에서는 RIGHT JOIN보다 테이블 순서를 바꿔서 LEFT JOIN으로 작성하는 경우가 훨씬 많습니다. LEFT JOIN이 읽는 방향과 일치하여 가독성이 좋기 때문입니다.

## 심화/실무 (10~12)

**Q10.** JPA에서 N+1 문제란 무엇이고, JOIN FETCH로 어떻게 해결하나요?

> N+1 문제는 연관 엔티티를 LAZY 로딩으로 설정했을 때, 부모 엔티티를 조회한 후 자식 엔티티에 접근할 때마다 추가 쿼리가 발생하는 문제입니다. 예를 들어 직원 10명을 조회하면 1번의 SELECT로 직원을 가져오고, 각 직원의 부서 정보에 접근할 때마다 추가 쿼리가 발생하여 총 11번의 쿼리가 실행됩니다. JOIN FETCH를 사용하면 JPQL에서 `SELECT e FROM Employee e LEFT JOIN FETCH e.department`처럼 작성하여 한 번의 쿼리로 연관 데이터를 함께 가져올 수 있습니다. EntityGraph나 Batch Size 설정도 대안입니다.

**Q11.** JPQL에서 JOIN과 JOIN FETCH의 차이는 무엇인가요?

> JPQL의 JOIN은 SQL의 JOIN과 동일하게 연관 엔티티를 조인하지만, SELECT 절에 명시하지 않으면 연관 엔티티를 영속성 컨텍스트에 로딩하지 않습니다. 이후 연관 엔티티에 접근하면 추가 쿼리가 발생합니다. 반면 JOIN FETCH는 연관 엔티티를 즉시 로딩하여 영속성 컨텍스트에 함께 올려둡니다. N+1 문제를 해결할 때는 일반 JOIN이 아닌 JOIN FETCH를 사용해야 합니다.

**Q12.** MySQL에서 FULL OUTER JOIN을 지원하지 않는데, 이를 어떻게 구현할 수 있나요?

> MySQL에서는 LEFT JOIN과 RIGHT JOIN의 결과를 UNION으로 합쳐서 FULL OUTER JOIN을 구현할 수 있습니다. LEFT JOIN으로 왼쪽 테이블 기준 결과를 가져오고, RIGHT JOIN으로 오른쪽 테이블 기준 결과를 가져온 뒤 UNION으로 합치면 중복이 제거되어 양쪽 모두 포함하는 결과를 얻을 수 있습니다. UNION ALL을 사용하면 중복이 포함되므로 주의해야 합니다.

## 꼬리질문 대비 (13~15)

**Q13.** JOIN FETCH 사용 시 페이징(Pagination)이 안 되는 문제를 경험한 적이 있나요? 해결 방법은 무엇인가요?

> JOIN FETCH와 페이징을 함께 사용하면 Hibernate가 메모리에서 페이징을 수행하여 경고가 발생하고 성능 문제가 생길 수 있습니다. 이는 컬렉션 JOIN FETCH 시 데이터가 뻥튀기되어 정확한 페이징이 불가능하기 때문입니다. 해결 방법으로는 첫째, @BatchSize를 설정하여 IN 쿼리로 연관 엔티티를 한 번에 가져오는 방법이 있습니다. 둘째, 부모 엔티티만 페이징 조회한 후 별도의 쿼리로 연관 엔티티를 가져오는 방법이 있습니다. 셋째, 조회 전용 DTO로 필요한 데이터만 직접 조회하는 방법이 있습니다.

**Q14.** EXPLAIN으로 실행 계획을 확인한다고 했는데, 실행 계획에서 어떤 정보를 중점적으로 확인해야 하나요?

> EXPLAIN 결과에서 가장 중요한 것은 type 컬럼입니다. const, eq_ref, ref는 인덱스를 잘 활용하는 것이고, ALL은 Full Table Scan으로 최악의 경우입니다. key 컬럼에서 실제 사용된 인덱스를 확인하고, rows 컬럼에서 예상 조회 행 수를 확인합니다. Extra 컬럼에서 Using index는 커버링 인덱스 적용을, Using filesort는 추가 정렬이 필요함을, Using temporary는 임시 테이블 사용을 의미합니다. type이 ALL이거나 rows가 매우 크다면 인덱스 추가나 쿼리 최적화를 고려해야 합니다.

**Q15.** QueryDSL은 왜 사용하나요? JPQL 대비 어떤 장점이 있나요?

> QueryDSL의 가장 큰 장점은 타입 안전성과 동적 쿼리 작성의 편의성입니다. JPQL은 문자열 기반이라 컴파일 시점에 오류를 잡을 수 없지만, QueryDSL은 자바 코드로 쿼리를 작성하므로 컴파일 시점에 문법 오류를 감지할 수 있습니다. 또한 BooleanBuilder 등을 활용하여 조건에 따라 동적으로 WHERE 절을 구성할 수 있어, 검색 조건이 여러 개인 경우 깔끔하게 처리할 수 있습니다. JOIN FETCH와 페이징도 메서드 체이닝 방식으로 직관적으로 작성할 수 있습니다.
