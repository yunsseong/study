# 인덱스(Index) 면접 질문 + 답변

## 기본 개념 (1~5)

**Q1.** 인덱스란 무엇이고, 왜 필요한가요?

> 인덱스는 데이터베이스 테이블의 검색 속도를 높이기 위한 별도의 자료 구조입니다. 책의 맨 뒤에 있는 색인(찾아보기)과 같은 원리입니다. 인덱스가 없으면 테이블의 모든 행을 순차적으로 확인하는 Full Table Scan이 발생하여 O(N)의 시간이 걸리지만, B+Tree 인덱스를 사용하면 O(log N)으로 탐색할 수 있습니다. 예를 들어 100만 건의 데이터에서 Full Scan은 100만 번 비교가 필요하지만, 인덱스는 약 20번의 비교만으로 충분합니다.

**Q2.** B+Tree 구조에 대해 설명해주세요. MySQL InnoDB가 B+Tree를 사용하는 이유는 무엇인가요?

> B+Tree는 리프 노드에만 실제 데이터를 저장하고, 리프 노드끼리 연결 리스트로 연결된 균형 트리 구조입니다. 내부 노드에는 키만 저장하여 탐색 경로를 안내합니다. MySQL InnoDB가 B+Tree를 사용하는 이유는 세 가지입니다. 첫째, 리프 노드가 연결 리스트로 연결되어 있어 BETWEEN, 범위 검색 같은 쿼리에서 리프 노드를 순서대로 읽으면 되므로 범위 검색에 강합니다. 둘째, 내부 노드에 데이터 포인터가 없으므로 더 많은 키를 저장할 수 있어 트리 높이가 낮아지고 디스크 I/O가 줄어듭니다. 셋째, 리프 노드 연결 덕분에 ORDER BY 정렬에도 유리합니다.

**Q3.** 클러스터드 인덱스란 무엇인가요? MySQL에서 어떻게 생성되나요?

> 클러스터드 인덱스는 실제 데이터가 인덱스 키 순서대로 물리적으로 정렬되어 저장되는 인덱스입니다. 사전에서 단어가 알파벳 순서로 직접 정렬되어 있는 것과 같습니다. 테이블당 하나만 가능하며, MySQL InnoDB에서는 PK(Primary Key)가 자동으로 클러스터드 인덱스가 됩니다. 범위 검색 시 물리적으로 연속된 데이터를 읽으므로 매우 빠르지만, INSERT 시 정렬 순서를 유지해야 하는 비용이 있습니다.

**Q4.** 복합 인덱스(Composite Index)란 무엇이고, 최좌선 접두사 규칙(Leftmost Prefix Rule)은 무엇인가요?

> 복합 인덱스는 여러 컬럼을 하나의 인덱스로 묶은 것입니다. 예를 들어 (department, name)으로 복합 인덱스를 만들면 department 순으로 먼저 정렬하고, 같은 department 내에서 name 순으로 정렬합니다. 최좌선 접두사 규칙은 복합 인덱스를 사용할 때 왼쪽 컬럼부터 순서대로 사용해야 인덱스를 탈 수 있다는 규칙입니다. (A, B, C) 인덱스에서 WHERE A=1은 인덱스를 타지만, WHERE B=2처럼 A를 건너뛰면 인덱스를 탈 수 없습니다. 전화번호부에서 성(A) 없이 이름(B)만으로 찾을 수 없는 것과 같습니다.

**Q5.** 인덱스의 단점은 무엇인가요?

> 인덱스는 세 가지 단점이 있습니다. 첫째, INSERT, UPDATE, DELETE 시 인덱스도 함께 갱신해야 하므로 쓰기 성능이 저하됩니다. 둘째, 인덱스 자체가 별도의 자료 구조이므로 추가 저장 공간을 사용합니다. 셋째, 인덱스가 너무 많으면 옵티마이저가 실행 계획을 수립할 때 고려할 경우의 수가 늘어나 오히려 비효율적일 수 있습니다. 따라서 읽기와 쓰기 비율을 고려하여 테이블당 3~5개 정도로 적절히 설계해야 합니다.

## 비교/구분 (6~9)

**Q6.** B-Tree와 B+Tree의 차이점을 설명해주세요.

> B-Tree는 모든 노드에 키와 데이터 포인터를 저장하는 반면, B+Tree는 리프 노드에만 데이터를 저장합니다. B-Tree는 중간 노드에서도 데이터를 찾을 수 있지만 범위 검색 시 트리를 재탐색해야 합니다. B+Tree는 리프 노드가 연결 리스트로 연결되어 있어 범위 검색 시 리프 노드만 순회하면 됩니다. 또한 B+Tree는 내부 노드에 데이터 포인터가 없으므로 같은 크기의 노드에 더 많은 키를 저장할 수 있어 트리 높이가 낮아지고 디스크 I/O가 줄어듭니다. B+Tree는 항상 리프 노드까지 탐색하므로 검색 성능이 균일합니다.

**Q7.** 클러스터드 인덱스와 논클러스터드 인덱스의 차이를 설명해주세요.

> 클러스터드 인덱스는 실제 데이터가 인덱스 키 순서로 물리적으로 정렬되어 있어 테이블당 하나만 가능합니다. MySQL에서는 PK가 자동으로 클러스터드 인덱스가 됩니다. 범위 검색이 매우 빠르지만 INSERT 시 정렬 유지 비용이 있습니다. 논클러스터드 인덱스는 별도의 인덱스 구조가 실제 데이터의 위치를 포인터로 가리킵니다. 테이블에 여러 개 만들 수 있으며, 데이터 접근 시 포인터를 따라가야 하므로 클러스터드 인덱스보다 약간 느립니다. 책 뒤의 색인처럼 "김철수 -> 42쪽"으로 위치를 참조하는 방식입니다.

**Q8.** Full Table Scan과 인덱스 스캔의 성능 차이는 어떤가요? 옵티마이저가 Full Table Scan을 선택하는 경우는 언제인가요?

> Full Table Scan은 테이블의 모든 행을 순차적으로 읽으므로 O(N)이고, 인덱스 스캔은 B+Tree를 탐색하므로 O(log N)입니다. 100만 건 기준으로 Full Scan은 100만 번, 인덱스는 약 20번 비교만 필요합니다. 하지만 옵티마이저가 Full Table Scan을 선택하는 경우가 있습니다. 조회 결과가 전체 데이터의 약 20% 이상이면 인덱스를 타고 데이터 페이지를 랜덤 I/O로 읽는 것보다 Full Scan으로 순차 I/O를 하는 것이 더 효율적이기 때문입니다.

**Q9.** 커버링 인덱스(Covering Index)란 무엇이고, 일반 인덱스 조회와 어떻게 다른가요?

> 커버링 인덱스는 쿼리에 필요한 모든 컬럼이 인덱스에 포함되어 있어 테이블에 접근하지 않고 인덱스만으로 결과를 반환하는 것입니다. 예를 들어 (department, name) 인덱스가 있을 때 `SELECT department, name FROM employees WHERE department = '개발팀'`은 인덱스만으로 처리할 수 있습니다. 일반 인덱스 조회는 인덱스에서 위치를 찾은 뒤 실제 테이블 페이지에 다시 접근해야 하므로 추가 I/O가 발생합니다. EXPLAIN의 Extra 컬럼에 'Using index'가 표시되면 커버링 인덱스가 적용된 것입니다.

## 심화/실무 (10~13)

**Q10.** 인덱스가 있는데도 인덱스를 타지 않는 경우를 아는 대로 설명해주세요.

> 인덱스를 타지 않는 주요 경우는 다음과 같습니다. 첫째, 인덱스 컬럼에 함수나 연산을 적용하면 인덱스를 탈 수 없습니다. `WHERE YEAR(created_at) = 2024` 대신 범위 조건으로 변환해야 합니다. 둘째, 묵시적 형 변환이 발생하면 안 탑니다. VARCHAR 컬럼을 숫자로 비교하면 내부적으로 형 변환이 일어납니다. 셋째, LIKE 앞에 와일드카드를 쓰면 안 탑니다. `LIKE '%철수'`는 인덱스를 탈 수 없고, `LIKE '김%'`은 탈 수 있습니다. 넷째, OR 조건은 인덱스 활용이 제한적이며 UNION으로 분리하면 개선할 수 있습니다. 다섯째, NOT이나 != 같은 부정 조건도 인덱스 활용이 어렵습니다. 여섯째, 전체 데이터의 약 20% 이상을 조회하면 옵티마이저가 Full Scan을 선택합니다.

**Q11.** EXPLAIN 명령어로 확인할 수 있는 정보는 무엇인가요? type 컬럼의 의미를 설명해주세요.

> EXPLAIN은 쿼리의 실행 계획을 보여주는 명령어입니다. 주요 컬럼으로 type(접근 방식), key(사용된 인덱스), rows(예상 조회 행 수), Extra(추가 정보) 등이 있습니다. type 컬럼은 성능 순으로 system > const > eq_ref > ref > range > index > ALL입니다. const는 PK나 유니크 인덱스로 1건 조회, eq_ref는 JOIN에서 PK로 1건 매칭, ref는 인덱스로 여러 건 조회, range는 인덱스 범위 검색(BETWEEN 등), index는 인덱스 풀 스캔, ALL은 테이블 풀 스캔으로 최악의 경우입니다. type이 ALL이면 인덱스 추가나 쿼리 최적화가 필요합니다.

**Q12.** 복합 인덱스를 설계할 때 컬럼 순서를 어떻게 결정하나요?

> 복합 인덱스의 컬럼 순서는 세 가지 기준으로 결정합니다. 첫째, 카디널리티(고유 값 수)가 높은 컬럼을 앞에 배치합니다. 주민번호처럼 거의 유니크한 값이 성별(M/F)보다 앞에 와야 인덱스 효과가 큽니다. 둘째, WHERE 절에서 자주 사용되는 컬럼을 앞에 배치합니다. 최좌선 접두사 규칙에 의해 앞의 컬럼이 빠지면 인덱스를 활용할 수 없기 때문입니다. 셋째, 등호(=) 조건으로 사용되는 컬럼을 범위 조건(<, >, BETWEEN) 컬럼보다 앞에 배치합니다. 범위 조건 이후의 컬럼은 인덱스를 탈 수 없기 때문입니다.

**Q13.** Spring Data JPA에서 인덱스를 설정하는 방법과, 인덱스를 타지 않는 쿼리 메서드의 예시를 알려주세요.

> Spring Data JPA에서는 @Table 애노테이션의 indexes 속성으로 인덱스를 설정합니다. `@Table(indexes = {@Index(name = "idx_dept_name", columnList = "department, name")})` 형태로 선언합니다. unique 인덱스는 `@Index(columnList = "email", unique = true)`로 설정할 수 있습니다. 인덱스를 타지 않는 대표적 예시는 `findByNameContaining(String name)`입니다. 이 메서드는 `LIKE '%name%'`으로 변환되어 앞에 와일드카드가 붙으므로 인덱스를 타지 않습니다. 반면 `findByNameStartingWith(String prefix)`는 `LIKE 'prefix%'`로 변환되어 인덱스를 탈 수 있습니다.

## 꼬리질문 대비 (14~15)

**Q14.** 카디널리티(Cardinality)란 무엇이고, 인덱스 설계 시 왜 중요한가요?

> 카디널리티는 해당 컬럼의 고유 값 수를 의미합니다. 주민번호는 카디널리티가 매우 높고(거의 유니크), 성별은 매우 낮습니다(M/F 두 가지). 카디널리티가 높은 컬럼에 인덱스를 걸어야 효과가 큽니다. 성별처럼 카디널리티가 낮은 컬럼은 인덱스를 타더라도 전체 데이터의 50%를 읽어야 하므로 옵티마이저가 Full Scan을 선택할 가능성이 높습니다. 복합 인덱스에서도 카디널리티가 높은 컬럼을 앞에 배치하면 초기 탐색에서 후보 행을 크게 줄일 수 있어 효율적입니다.

**Q15.** 인덱스를 너무 많이 만들면 어떤 문제가 생기나요? 적절한 인덱스 개수의 기준이 있나요?

> 인덱스가 너무 많으면 세 가지 문제가 발생합니다. 첫째, INSERT, UPDATE, DELETE 시마다 모든 관련 인덱스를 갱신해야 하므로 쓰기 성능이 크게 저하됩니다. 둘째, 각 인덱스가 별도의 B+Tree 구조를 유지하므로 저장 공간이 크게 증가합니다. 셋째, 옵티마이저가 어떤 인덱스를 사용할지 결정하는 과정이 복잡해져 쿼리 최적화가 비효율적일 수 있습니다. 일반적으로 테이블당 3~5개가 적절한 기준이며, 읽기 위주 시스템이면 더 많이, 쓰기 위주 시스템이면 최소한으로 유지하는 것이 좋습니다. 사용되지 않는 인덱스는 주기적으로 확인하여 제거해야 합니다.
