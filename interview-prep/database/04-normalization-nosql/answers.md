# 정규화와 NoSQL 면접 질문 + 답변

## 기본 개념 (1~5)

**Q1.** 정규화란 무엇이고, 왜 필요한가요?

> 정규화는 데이터 중복을 제거하고 무결성을 보장하기 위해 테이블을 분리하는 과정입니다. 정규화가 되지 않은 테이블에서는 삽입 이상, 갱신 이상, 삭제 이상이 발생합니다. 예를 들어 학생과 수강 정보가 한 테이블에 있으면, 새 과목을 추가할 때 학생이 없으면 삽입할 수 없고(삽입 이상), 교수 이름 변경 시 여러 행을 모두 수정해야 하며(갱신 이상), 학생을 삭제하면 과목 정보도 함께 사라집니다(삭제 이상). 정규화를 통해 이런 이상 현상을 방지할 수 있습니다.

**Q2.** 이상 현상(Anomaly) 세 가지를 설명해주세요.

> 삽입 이상은 불필요한 데이터 없이는 원하는 데이터를 삽입할 수 없는 문제입니다. 예를 들어 새 과목을 추가하려면 반드시 수강 학생이 있어야 삽입 가능한 경우입니다. 갱신 이상은 중복된 데이터 중 일부만 수정하면 데이터 불일치가 발생하는 문제입니다. 이교수의 이름이 여러 행에 있으면 모든 행을 수정해야 합니다. 삭제 이상은 특정 데이터를 삭제할 때 의도하지 않은 다른 데이터도 함께 삭제되는 문제입니다. 유일한 학생을 삭제하면 해당 과목 정보까지 사라지는 경우입니다.

**Q3.** 제1정규형(1NF), 제2정규형(2NF), 제3정규형(3NF)의 핵심 조건을 각각 설명해주세요.

> 제1정규형(1NF)은 모든 속성의 값이 원자값이어야 합니다. 한 칸에 하나의 값만 들어가야 하며, 반복 그룹이나 다중 값을 제거합니다. 예를 들어 전화번호 칸에 두 개의 번호가 있으면 1NF 위반입니다. 제2정규형(2NF)은 1NF를 만족하면서 부분 함수 종속을 제거합니다. 복합 키의 일부에만 종속되는 컬럼을 별도 테이블로 분리합니다. 제3정규형(3NF)은 2NF를 만족하면서 이행 함수 종속을 제거합니다. A가 B를 결정하고 B가 C를 결정하는 관계(A -> B -> C)에서 A -> C를 제거하기 위해 테이블을 분리합니다.

**Q4.** NoSQL이란 무엇이고, 어떤 배경에서 등장했나요?

> NoSQL은 "Not Only SQL"의 약자로, 관계형 데이터베이스 외의 다양한 데이터 저장 방식을 총칭합니다. SNS, IoT 등 비정형 데이터의 폭발적 증가와 수억 건 이상의 데이터를 처리하기 위한 수평 확장(Scale-Out) 필요, 유연한 스키마 변경 요구에 의해 등장했습니다. 유연한 스키마, 분산 환경에 최적화된 구조, 수평 확장 용이성이 특징이며, RDBMS의 ACID 대신 대부분 Eventually Consistent(최종 일관성) 모델을 채택합니다.

**Q5.** Redis란 무엇이고, 왜 빠른가요?

> Redis는 Remote Dictionary Server의 약자로 인메모리(In-Memory) Key-Value 데이터 저장소입니다. Redis가 빠른 이유는 첫째, 데이터를 디스크가 아닌 메모리(RAM)에 저장하여 디스크 I/O가 발생하지 않습니다. 일반 DB의 읽기가 약 10ms라면 Redis는 약 0.1ms로 100배 빠릅니다. 둘째, 싱글 스레드로 동작하여 컨텍스트 스위칭 비용이 없고 Lock 경합도 없습니다. 셋째, String, List, Set, Hash, Sorted Set 등 다양한 자료구조를 네이티브로 지원하여 복잡한 연산도 서버 측에서 효율적으로 처리합니다.

## 비교/구분 (6~9)

**Q6.** RDBMS와 NoSQL의 차이를 설명해주세요. 각각 어떤 상황에 적합한가요?

> RDBMS는 고정된 스키마, SQL 질의, ACID 트랜잭션을 보장하며, JOIN으로 테이블 간 관계를 표현합니다. 수직 확장(Scale-Up)이 주된 확장 방식이고, 구조화된 데이터와 복잡한 쿼리가 필요한 경우에 적합합니다. NoSQL은 유연한 스키마, 각 DB별 질의 방식을 사용하며, 대부분 Eventually Consistent 모델입니다. 수평 확장(Scale-Out)이 용이하고, 비정형 데이터와 대규모 분산 처리가 필요한 경우에 적합합니다. 서비스 특성에 따라 RDBMS와 NoSQL을 병행 사용하는 Polyglot Persistence 전략이 일반적입니다.

**Q7.** 정규화와 반정규화의 트레이드오프를 설명해주세요. 반정규화는 언제 고려하나요?

> 정규화는 데이터 무결성이 높고 중복이 없어 쓰기 성능이 좋지만, 테이블이 분리되어 JOIN이 많아지고 읽기 성능이 저하될 수 있습니다. 반정규화는 의도적으로 중복을 허용하여 JOIN을 줄이고 읽기 성능을 높이지만, 데이터 불일치 위험과 갱신 비용이 증가합니다. 반정규화는 정규화된 테이블에서 JOIN이 과도하게 많아 읽기 성능이 저하될 때 고려합니다. OLTP(쓰기 위주) 시스템은 정규화를 유지하고, 분석이나 조회 위주 시스템에서 반정규화를 적용합니다. 테이블 병합, 컬럼 중복, 파생 컬럼 추가, 요약 테이블 생성 등의 기법이 있습니다.

**Q8.** NoSQL의 4가지 종류(Key-Value, Document, Column-Family, Graph)를 각각의 적합한 사용 사례와 함께 설명해주세요.

> Key-Value Store(Redis, Memcached)는 Key-Value 쌍으로 저장하며 O(1)의 초고속 읽기/쓰기가 가능합니다. 캐시, 세션 저장에 적합합니다. Document Store(MongoDB)는 JSON 형태의 문서를 저장하며 스키마가 유연하고 중첩 구조를 표현할 수 있습니다. 콘텐츠 관리, 카탈로그에 적합합니다. Column-Family Store(Cassandra, HBase)는 행마다 컬럼이 달라도 되며 대규모 쓰기 성능이 뛰어납니다. 시계열 데이터, 로그 분석에 적합합니다. Graph Database(Neo4j)는 노드와 관계를 일급 시민으로 다루어 복잡한 관계 탐색이 매우 빠릅니다. SNS, 추천 시스템, 경로 탐색에 적합합니다.

**Q9.** CAP 정리란 무엇이고, RDBMS와 NoSQL은 각각 어디에 해당하나요?

> CAP 정리는 분산 시스템에서 일관성(Consistency), 가용성(Availability), 분할 내성(Partition Tolerance) 세 가지를 동시에 만족할 수 없다는 이론입니다. 최대 두 가지만 선택할 수 있습니다. RDBMS는 일반적으로 CA(일관성 + 가용성)를 선택하여 강한 일관성과 가용성을 보장하지만 분할 내성이 약합니다. NoSQL은 분산 환경에 최적화되어 CP(일관성 + 분할 내성) 또는 AP(가용성 + 분할 내성)를 선택합니다. 예를 들어 MongoDB는 CP를, Cassandra는 AP를 기본으로 합니다.

## 심화/실무 (10~12)

**Q10.** Spring Boot에서 Redis 캐시를 적용하는 방법을 설명해주세요. @Cacheable, @CacheEvict는 어떻게 동작하나요?

> Spring Boot에서 Redis 캐시를 적용하려면 spring-boot-starter-data-redis와 spring-boot-starter-cache 의존성을 추가하고, @EnableCaching으로 캐시 기능을 활성화합니다. @Cacheable(value = "products", key = "#productId")를 메서드에 붙이면, 첫 호출 시 메서드를 실행하여 결과를 Redis에 저장하고, 이후 같은 key로 호출하면 메서드를 실행하지 않고 Redis에서 바로 반환합니다(Cache Hit). @CacheEvict는 지정된 캐시를 삭제합니다. 데이터 삭제나 수정 시 @CacheEvict로 기존 캐시를 제거하여 오래된 데이터가 반환되는 것을 방지합니다. @CachePut은 항상 메서드를 실행하고 결과를 캐시에 갱신합니다.

**Q11.** BCNF(Boyce-Codd Normal Form)란 무엇이고, 3NF와 어떻게 다른가요?

> BCNF는 3NF를 만족하면서 모든 결정자가 후보키여야 한다는 더 엄격한 조건입니다. 3NF에서는 기본키가 아닌 속성 간의 이행 종속만 제거하지만, 후보키가 아닌 속성이 결정자인 경우를 허용할 수 있습니다. 예를 들어 수강 테이블(학생ID, 과목, 교수)에서 교수가 하나의 과목만 담당한다면 교수 -> 과목 함수 종속이 존재합니다. 교수가 결정자이지만 후보키가 아니므로 BCNF를 위반합니다. 이 경우 수강(학생ID, 교수)과 교수_과목(교수, 과목)으로 분리하여 BCNF를 충족시킵니다.

**Q12.** 분산 환경에서 Redis를 세션 저장소로 사용하는 이유와 방법을 설명해주세요.

> 분산 환경에서 서버 메모리에 세션을 저장하면 로드밸런서가 다른 서버로 요청을 보낼 때 세션을 찾지 못하는 문제가 발생합니다. Redis를 세션 저장소로 사용하면 모든 서버가 하나의 Redis에서 세션을 공유하므로 어느 서버로 요청이 가더라도 세션이 유지됩니다. Spring Boot에서는 spring-session-data-redis 의존성을 추가하고, @EnableRedisHttpSession 애노테이션으로 설정합니다. maxInactiveIntervalInSeconds 속성으로 세션 만료 시간을 설정할 수 있고, application.yml에서 spring.session.store-type을 redis로 지정합니다.

## 꼬리질문 대비 (13~15)

**Q13.** Redis의 영속성 옵션인 RDB와 AOF의 차이는 무엇인가요?

> RDB(Redis Database)는 특정 시점의 메모리 스냅샷을 디스크에 저장하는 방식입니다. 주기적으로 전체 데이터를 덤프하므로 복구가 빠르고 파일 크기가 작지만, 마지막 스냅샷 이후의 데이터는 유실될 수 있습니다. AOF(Append Only File)는 모든 쓰기 연산을 로그 파일에 순서대로 기록하는 방식입니다. 데이터 유실이 거의 없지만 파일 크기가 커지고 복구 시간이 길어질 수 있습니다. 실무에서는 두 가지를 함께 사용하여 RDB로 빠른 복구를 하고, AOF로 마지막 스냅샷 이후의 데이터를 복원하는 전략을 사용합니다.

**Q14.** Spring에서 Redis 캐시를 사용할 때 캐시 무효화 전략은 어떻게 설계해야 하나요?

> 캐시 무효화 전략의 핵심은 데이터 변경 시 캐시와 DB의 불일치를 방지하는 것입니다. 데이터 수정 시 @CachePut으로 캐시를 갱신하거나 @CacheEvict로 캐시를 삭제해야 합니다. TTL(Time To Live)을 적절히 설정하여 캐시가 자동 만료되게 합니다. 캐시 대상은 자주 조회되지만 변경이 적은 데이터를 선정해야 합니다. 또한 직렬화/역직렬화 비용과 메모리 용량도 고려해야 합니다. 캐시 스탬피드(동시에 많은 요청이 캐시 미스를 발생시키는 현상)를 방지하기 위해 Lock 기반 캐시 갱신이나 TTL에 랜덤 값을 추가하는 전략도 중요합니다.

**Q15.** Redis가 싱글 스레드인데 어떻게 높은 성능을 유지할 수 있나요?

> Redis가 싱글 스레드로도 높은 성능을 유지할 수 있는 이유는 여러 가지입니다. 첫째, 모든 데이터가 메모리에 있어 디스크 I/O 대기 시간이 없습니다. 둘째, 싱글 스레드이므로 Lock 경합, 컨텍스트 스위칭, 동기화 오버헤드가 없습니다. 셋째, I/O 멀티플렉싱(epoll/kqueue)을 사용하여 하나의 스레드로 수천 개의 클라이언트 연결을 효율적으로 처리합니다. 넷째, 각 명령어의 처리 시간이 마이크로초 단위로 매우 짧아 순차 처리해도 충분한 처리량을 보입니다. 다만 오래 걸리는 명령어(KEYS * 등)는 전체 시스템을 블로킹하므로 주의해야 합니다.
