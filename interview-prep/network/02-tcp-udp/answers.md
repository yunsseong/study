# TCP vs UDP 면접 질문 + 답변

---

## 기본 개념

### Q1. TCP와 UDP의 차이점을 설명해주세요.

> TCP는 연결 지향 프로토콜로 3-way handshake로 연결을 맺고,
> ACK를 통해 신뢰성, 순서 보장, 흐름 제어, 혼잡 제어를 제공합니다.
> UDP는 비연결 프로토콜로 연결 없이 바로 전송하며,
> 신뢰성은 보장하지 않지만 오버헤드가 적어 빠릅니다.
> HTTP 같은 웹 통신은 정확성이 중요하므로 TCP를,
> 스트리밍이나 게임은 속도가 중요하므로 UDP를 사용합니다.

---

### Q2. TCP의 신뢰성이란 구체적으로 무엇을 의미하나요?

> TCP의 신뢰성은 크게 3가지를 보장합니다.
> 첫째, **데이터 도착 보장** - ACK가 오지 않으면 재전송합니다.
> 둘째, **순서 보장** - 시퀀스 번호로 패킷 순서를 추적하여 뒤섞여 도착해도 원래 순서로 정렬합니다.
> 셋째, **데이터 무결성** - 체크섬으로 전송 중 데이터가 손상되지 않았는지 확인합니다.

---

### Q3. TCP의 흐름 제어(Flow Control)와 혼잡 제어(Congestion Control)의 차이를 설명해주세요.

> 흐름 제어는 **수신 측의 처리 속도**에 맞춰 전송 속도를 조절하는 것입니다.
> 수신 측이 Window Size를 알려주면, 송신 측은 그만큼만 보냅니다.
> 받는 쪽이 감당 못할 만큼 보내지 않도록 조절합니다.
>
> 혼잡 제어는 **네트워크 상태**에 따라 전송 속도를 조절하는 것입니다.
> 패킷 유실이 감지되면 네트워크가 혼잡하다고 판단하여 전송량을 줄입니다.
>
> 정리하면, 흐름 제어는 "받는 쪽이 느려서" 조절, 혼잡 제어는 "네트워크가 막혀서" 조절입니다.

---

### Q4. UDP는 신뢰성을 보장하지 않는데 왜 사용하나요?

> 속도가 중요하고 약간의 데이터 손실이 허용되는 경우에 사용합니다.
> TCP는 연결 수립, ACK 확인, 재전송, 순서 정렬 등의 오버헤드가 있어 느립니다.
> 영상 스트리밍에서 1프레임이 빠져도 눈에 띄지 않지만, 버퍼링(지연)은 치명적입니다.
> 온라인 게임에서 0.1초 전 위치를 재전송하는 것보다 최신 위치를 빨리 받는 게 중요합니다.
> 이런 상황에서 TCP의 신뢰성 보장은 오히려 성능을 떨어뜨립니다.

---

### Q5. TCP와 UDP의 헤더 크기 차이는 왜 생기나요?

> TCP 헤더는 20바이트, UDP 헤더는 8바이트입니다.
> TCP는 신뢰성을 위한 필드가 많기 때문입니다.
> 시퀀스 번호(순서 추적), ACK 번호(수신 확인), 윈도우 사이즈(흐름 제어),
> 플래그(SYN, ACK, FIN 등) 같은 정보를 헤더에 담아야 합니다.
> UDP는 이런 기능이 없으므로 출발 포트, 도착 포트, 길이, 체크섬만 있으면 됩니다.

---

## 비교/구분

### Q6. TCP를 사용하는 프로토콜과 UDP를 사용하는 프로토콜을 각각 3개씩 말하고, 왜 그 프로토콜을 쓰는지 설명해주세요.

> **TCP**: HTTP(웹 페이지가 깨지면 안 됨), FTP(파일이 손상되면 안 됨), SMTP(이메일 내용이 유실되면 안 됨)
> → 데이터의 정확성과 완전성이 중요한 경우
>
> **UDP**: DNS(작은 데이터를 빠르게 응답), 스트리밍(실시간성이 중요), 온라인 게임(지연이 치명적)
> → 속도가 중요하고 약간의 손실이 허용되는 경우

---

### Q7. 온라인 게임은 왜 UDP를 쓰나요? 패킷이 유실되면 어떻게 하나요?

> 게임은 실시간성이 가장 중요합니다.
> TCP를 쓰면 패킷 유실 시 재전송을 기다려야 하고, 그동안 화면이 멈춥니다.
> UDP를 쓰면 유실된 패킷은 무시하고 최신 데이터를 바로 처리합니다.
>
> 패킷 유실에 대해서는 애플리케이션 레벨에서 처리합니다.
> 예를 들어 캐릭터 위치를 매 프레임 보내므로, 한 패킷이 유실되어도
> 다음 패킷에 최신 위치가 담겨있어 큰 문제가 없습니다.
> 중요한 이벤트(아이템 획득 등)는 별도로 확인 로직을 구현합니다.

---

### Q8. DNS는 왜 UDP를 쓰나요?

> DNS 질의는 보통 매우 작은 데이터(수백 바이트)를 한 번 주고받는 것이므로,
> TCP처럼 연결을 맺고 끊는 오버헤드가 비효율적입니다.
> UDP로 질의 1번, 응답 1번이면 끝나서 빠릅니다.
>
> 단, DNS 응답이 512바이트를 초과하거나 영역 전송(Zone Transfer)처럼
> 대량 데이터를 주고받는 경우에는 TCP를 사용합니다.

---

### Q9. 세그먼트와 데이터그램의 차이는 무엇인가요?

> 둘 다 전송 계층의 PDU(데이터 단위)이지만, 프로토콜이 다릅니다.
> 세그먼트는 TCP의 PDU로, 시퀀스 번호와 ACK 번호 등 신뢰성 정보를 포함합니다.
> 데이터그램은 UDP의 PDU로, 최소한의 헤더(포트, 길이, 체크섬)만 포함합니다.

---

## 심화/실무

### Q10. HTTP/3는 왜 TCP가 아닌 UDP 기반(QUIC)을 사용하나요?

> TCP는 두 가지 문제가 있습니다.
> 첫째, 연결 수립이 느립니다. TCP 3-way handshake + TLS handshake로 최소 2~3 RTT가 필요합니다.
> 둘째, Head-of-Line Blocking 문제가 있습니다. 하나의 패킷이 유실되면
> 뒤의 모든 패킷이 대기해야 합니다.
>
> QUIC은 UDP 위에서 자체적으로 연결 관리와 신뢰성을 구현합니다.
> 연결 수립을 0~1 RTT로 줄이고, 스트림별로 독립적으로 처리하여
> Head-of-Line Blocking을 해결합니다.
> TCP의 장점(신뢰성)과 UDP의 장점(속도)을 합친 것입니다.

---

### Q11. UDP인데 신뢰성이 필요하면 어떻게 해결하나요?

> 애플리케이션 레벨에서 직접 신뢰성을 구현할 수 있습니다.
> 대표적인 예가 HTTP/3의 QUIC 프로토콜입니다.
> QUIC은 UDP 위에서 자체적으로 패킷 번호 관리, ACK, 재전송을 구현합니다.
>
> 게임에서도 중요한 데이터(아이템 거래 등)에 대해서는
> 별도의 확인/재전송 로직을 애플리케이션에서 구현합니다.
> 이렇게 하면 필요한 부분만 선택적으로 신뢰성을 확보할 수 있습니다.

---

### Q12. TCP는 왜 느린가요? 구체적으로 어떤 오버헤드가 있나요?

> 4가지 주요 오버헤드가 있습니다.
> 1. **연결 수립**: 3-way handshake에 1.5 RTT 소요
> 2. **ACK 대기**: 매 패킷마다 수신 확인을 기다림
> 3. **재전송 대기**: 패킷 유실 시 타임아웃까지 대기 후 재전송
> 4. **순서 정렬 대기**: 앞선 패킷이 안 오면 뒤의 패킷도 대기 (Head-of-Line Blocking)
>
> 이 모든 작업이 신뢰성을 위해 필수적이지만, 그만큼 지연이 발생합니다.

---

### Q13. Spring Boot는 왜 TCP를 사용하나요? UDP를 쓰면 안 되나요?

> Spring Boot는 HTTP 기반 웹 서버이고, HTTP는 TCP 위에서 동작하기 때문입니다.
> 웹 요청/응답은 데이터가 정확하게 전달되어야 합니다.
> JSON 응답의 일부가 유실되면 파싱 에러가 발생하고,
> 순서가 바뀌면 응답이 깨집니다.
>
> 다만 Spring에서 WebSocket을 쓸 때는 실시간 통신이 필요하며,
> 향후 HTTP/3를 지원하면 내부적으로는 UDP(QUIC) 기반이 됩니다.
> 하지만 이 경우에도 QUIC이 신뢰성을 보장하므로 애플리케이션 관점에서는 TCP와 유사합니다.

---

## 꼬리질문

### Q14. TCP의 순서 보장은 어떤 메커니즘으로 동작하나요?

> TCP는 각 바이트에 시퀀스 번호(Sequence Number)를 부여합니다.
> 수신 측은 시퀀스 번호를 확인하여 패킷이 순서대로 도착했는지 판단합니다.
> 패킷이 뒤섞여 도착하면 버퍼에 보관하다가, 빠진 패킷이 도착하면 순서대로 정렬하여
> 상위 계층에 전달합니다.
>
> 예: 패킷 1, 3, 2 순서로 도착 → 1은 바로 전달, 3은 버퍼에 보관, 2 도착하면 2, 3 순서로 전달

---

### Q15. "연결 지향"이란 구체적으로 무엇을 의미하나요? 물리적 연결인가요?

> 물리적 연결이 아니라 **논리적 연결**입니다.
> 3-way handshake를 통해 양쪽이 "지금부터 통신하겠다"고 합의하고,
> 시퀀스 번호, 윈도우 사이즈 등의 상태 정보를 양쪽 모두 유지합니다.
> 이 상태 정보가 유지되는 동안을 "연결되어 있다"고 합니다.
>
> 반면 UDP는 이런 상태 정보 없이 그냥 보내므로 "비연결"입니다.
> 각 데이터그램은 독립적이며, 이전에 보낸 것과 아무 관계가 없습니다.
