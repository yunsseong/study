# 2. TCP vs UDP

---

## 전송 계층이 하는 일

OSI 4계층(전송 계층)에는 두 가지 프로토콜이 있다:
- **TCP**: 안전하게 보내기 (느리지만 확실)
- **UDP**: 빠르게 보내기 (빠르지만 불확실)

둘 다 **포트 번호**를 써서 데이터를 알맞은 프로세스에 전달한다.

---

## TCP (Transmission Control Protocol)

### 핵심 특징

**연결 지향(Connection-oriented)**: 데이터를 보내기 전에 먼저 연결을 맺는다.

```
[클라이언트] ←── 연결 맺기 (3-way handshake) ──→ [서버]
[클라이언트] ←── 데이터 주고받기 ──→ [서버]
[클라이언트] ←── 연결 끊기 (4-way handshake) ──→ [서버]
```

전화 통화와 같다:
1. 전화 걸기 (연결)
2. 대화하기 (데이터 전송)
3. 끊기 (연결 해제)

### TCP가 보장하는 것들

**1. 신뢰성 (Reliability)**
데이터가 반드시 도착한다. 안 도착하면 다시 보낸다.

```
보내는 쪽: 패킷 1 전송 →
받는 쪽:   ← ACK 1 (잘 받았다는 응답)

보내는 쪽: 패킷 2 전송 →
           ... (응답 없음, 유실됨)
보내는 쪽: 패킷 2 재전송 →  ← 일정 시간 내 ACK 안 오면 다시 보냄
받는 쪽:   ← ACK 2
```

**2. 순서 보장 (Ordering)**
데이터가 보낸 순서대로 도착한다.

```
보낸 순서: 패킷1 → 패킷2 → 패킷3
네트워크에서: 패킷1, 패킷3, 패킷2 (뒤섞여 도착)
TCP가 재정렬: 패킷1 → 패킷2 → 패킷3 (원래 순서로)
```

각 패킷에 **시퀀스 번호(Sequence Number)**가 있어서 순서를 알 수 있다.

**3. 흐름 제어 (Flow Control)**
받는 쪽이 처리할 수 있는 속도에 맞춰 보낸다.

```
받는 쪽: "나 지금 버퍼에 여유 100 있어" (Window Size)
보내는 쪽: 100만큼만 보냄

받는 쪽: "지금 바빠, 여유 10밖에 없어"
보내는 쪽: 10만큼만 보냄
```

느린 컴퓨터에 데이터를 폭주시키지 않도록 조절하는 것.

**4. 혼잡 제어 (Congestion Control)**
네트워크가 혼잡하면 전송 속도를 줄인다.

```
네트워크 상태 좋음 → 많이 보냄
패킷 유실 감지    → 네트워크 혼잡하구나 → 속도 줄임
상태 나아짐      → 다시 조금씩 속도 올림
```

도로가 막히면 차를 천천히 보내는 것과 같다.

### TCP를 쓰는 곳

| 프로토콜 | 용도 | 왜 TCP? |
|---------|------|--------|
| HTTP/HTTPS | 웹 | 웹 페이지가 깨지면 안 되니까 |
| FTP | 파일 전송 | 파일이 손상되면 안 되니까 |
| SMTP | 이메일 | 이메일 내용이 빠지면 안 되니까 |
| SSH | 원격 접속 | 명령어가 정확히 전달되어야 하니까 |

---

## UDP (User Datagram Protocol)

### 핵심 특징

**비연결(Connectionless)**: 연결 없이 그냥 보낸다.

```
[클라이언트] ── 데이터 전송 ──→ [서버]
                (연결 과정 없음, 받았는지 확인 안 함)
```

편지와 같다:
1. 편지 쓰기
2. 우체통에 넣기 (도착했는지 확인 안 함)

### UDP의 특징

```
연결 수립:   없음 (그냥 보냄)
신뢰성:     보장 안 함 (유실돼도 모름)
순서 보장:   없음 (뒤섞일 수 있음)
흐름 제어:   없음
혼잡 제어:   없음
속도:       빠름 (위의 것들을 안 하니까!)
헤더 크기:   8바이트 (TCP는 20바이트)
```

### 왜 이렇게 아무것도 안 하는데 쓸까?

**빠르기 때문이다.**

TCP는 안전하지만 그만큼 느리다:
- 연결 맺는 데 시간 소요 (3-way handshake)
- 매번 ACK 확인
- 유실되면 재전송 대기
- 순서 맞추기 위해 대기

**속도가 중요하고, 약간의 데이터 손실이 괜찮은 경우**에 UDP를 쓴다.

### UDP를 쓰는 곳

| 프로토콜 | 용도 | 왜 UDP? |
|---------|------|--------|
| DNS | 도메인→IP 변환 | 작은 데이터, 빠른 응답 필요 |
| 스트리밍 | 영상/음악 | 1프레임 빠져도 눈에 안 띔, 끊김이 더 문제 |
| 온라인 게임 | 실시간 통신 | 0.1초 전 위치 재전송보다 최신 위치가 중요 |
| VoIP | 인터넷 전화 | 음성은 실시간이 중요, 약간 끊겨도 통화 가능 |

---

## TCP vs UDP 비교표

| 항목 | TCP | UDP |
|------|-----|-----|
| 연결 | 연결 지향 (3-way handshake) | 비연결 |
| 신뢰성 | 보장 (ACK, 재전송) | 보장 안 함 |
| 순서 | 보장 (시퀀스 번호) | 보장 안 함 |
| 흐름 제어 | 있음 (Window) | 없음 |
| 혼잡 제어 | 있음 | 없음 |
| 속도 | 상대적 느림 | 빠름 |
| 헤더 크기 | 20바이트 | 8바이트 |
| PDU 이름 | 세그먼트 | 데이터그램 |
| 사용 예 | HTTP, FTP, SSH | DNS, 스트리밍, 게임 |

### 비유로 정리

```
TCP = 등기 우편
- 보내기 전에 수신자 확인
- 배달 완료 서명 받음
- 분실 시 다시 보냄
- 느리지만 확실

UDP = 전단지 뿌리기
- 그냥 뿌림
- 받았는지 확인 안 함
- 일부 날아가도 상관없음
- 빠르고 대량 전달 가능
```

---

## HTTP/3와 QUIC (심화 - 알면 면접에서 차별화)

전통적으로 HTTP는 TCP 위에서 동작했다:
- HTTP/1.1 → TCP
- HTTP/2 → TCP

그런데 **HTTP/3**는 **UDP 기반의 QUIC** 프로토콜을 쓴다.

```
기존: HTTP/2 → TCP → IP
신규: HTTP/3 → QUIC(UDP) → IP
```

왜?
- TCP는 연결 수립에 시간이 걸린다 (3-way handshake + TLS handshake)
- QUIC은 UDP 위에서 **자체적으로 신뢰성을 구현**하면서도 연결이 빠르다
- TCP의 장점(신뢰성) + UDP의 장점(속도)을 합친 것

> 면접에서 "UDP는 신뢰성이 없다"고만 답하면 부족하다.
> "UDP 위에서 애플리케이션 레벨로 신뢰성을 구현할 수 있다. HTTP/3의 QUIC이 그 예시"
> 라고 답하면 깊이가 다르다.

---

## Spring Boot와의 연결

```
Spring Boot 기본 설정:
- 내장 Tomcat이 TCP 포트 8080에서 대기
- 클라이언트가 TCP 연결 → HTTP 요청 전송
- Spring이 HTTP 요청 처리 후 TCP로 응답 전송

server.port=8080  ← 이것이 TCP 포트 번호
```

Spring Boot가 TCP를 쓰는 이유:
- 웹 요청/응답은 **정확하게** 전달되어야 한다
- JSON 데이터 일부가 유실되면 파싱 에러 발생
- 순서가 바뀌면 응답이 깨진다

---

## 면접 핵심 정리

**Q: TCP와 UDP의 차이점을 설명해주세요**
> TCP는 연결 지향 프로토콜로 3-way handshake로 연결을 맺고, ACK를 통해 신뢰성과 순서를 보장합니다.
> UDP는 비연결 프로토콜로 연결 없이 바로 전송하며, 신뢰성은 보장하지 않지만 빠릅니다.
> HTTP 같은 웹 통신은 정확성이 중요하므로 TCP를, 스트리밍이나 게임은 속도가 중요하므로 UDP를 사용합니다.

**Q: TCP는 왜 느린가요?**
> 연결 수립(3-way handshake), 매 패킷마다 ACK 확인, 유실 시 재전송, 순서 정렬 등
> 신뢰성을 보장하기 위한 작업들이 추가되기 때문입니다.

**Q: UDP인데 신뢰성이 필요하면 어떻게 하나요?**
> 애플리케이션 레벨에서 직접 신뢰성을 구현할 수 있습니다.
> HTTP/3의 QUIC 프로토콜이 대표적인 예로, UDP 위에서 자체적으로
> 연결 관리와 재전송을 구현하여 TCP의 장점과 UDP의 속도를 모두 얻었습니다.
