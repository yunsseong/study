# TCP Handshake 면접 질문 + 답변

---

## 기본 개념

### Q1. TCP 3-way handshake 과정을 설명해주세요.

> 클라이언트가 서버에 **SYN** 패킷을 보내 연결을 요청합니다.
> 서버가 **SYN + ACK** 패킷으로 요청을 수락하고 자신도 연결을 요청합니다.
> 클라이언트가 **ACK** 패킷을 보내 서버의 요청을 확인합니다.
> 이 3단계를 거치면 양쪽 모두 연결 준비가 완료되어 데이터를 주고받을 수 있습니다.
>
> ```
> 클라이언트 → SYN → 서버        "연결하자"
> 클라이언트 ← SYN+ACK ← 서버   "좋아, 나도 연결하자"
> 클라이언트 → ACK → 서버        "확인, 연결 완료"
> ```

---

### Q2. 3-way handshake에서 SYN, ACK가 각각 무엇인가요?

> **SYN**(Synchronize)은 연결을 시작하겠다는 요청 신호입니다.
> 자신의 시퀀스 번호를 상대에게 알리는 역할도 합니다.
>
> **ACK**(Acknowledge)는 상대의 요청을 확인했다는 응답 신호입니다.
> "너의 시퀀스 번호를 잘 받았다"는 의미입니다.
>
> 2단계에서 서버가 SYN+ACK를 동시에 보내는 것은
> "너의 요청 확인(ACK) + 나도 연결 요청(SYN)"을 합친 것입니다.

---

### Q3. TCP 4-way handshake 과정을 설명해주세요.

> 1. 클라이언트가 **FIN**을 보내 연결 종료를 요청합니다.
> 2. 서버가 **ACK**를 보내 수신을 확인합니다. (아직 보낼 데이터가 남아있을 수 있음)
> 3. 서버가 남은 데이터를 모두 전송한 후 **FIN**을 보냅니다.
> 4. 클라이언트가 **ACK**를 보내 확인하고, TIME_WAIT 후 연결이 종료됩니다.
>
> ```
> 클라이언트 → FIN → 서버       "나 끝"
> 클라이언트 ← ACK ← 서버      "알겠어, 잠깐"
> (서버가 남은 데이터 전송)
> 클라이언트 ← FIN ← 서버      "나도 끝"
> 클라이언트 → ACK → 서버      "확인"
> ```

---

### Q4. 3-way handshake 각 단계에서 클라이언트와 서버의 상태 변화를 설명해주세요.

> **Step 1 (SYN)**:
> - 클라이언트: CLOSED → SYN_SENT
> - 서버: LISTEN (대기 중)
>
> **Step 2 (SYN+ACK)**:
> - 서버: LISTEN → SYN_RECEIVED
> - 클라이언트: SYN_SENT (응답 대기 중)
>
> **Step 3 (ACK)**:
> - 클라이언트: SYN_SENT → ESTABLISHED
> - 서버: SYN_RECEIVED → ESTABLISHED
>
> 양쪽 모두 ESTABLISHED가 되면 데이터 전송이 가능합니다.

---

### Q5. 4-way handshake 각 단계에서 클라이언트와 서버의 상태 변화를 설명해주세요.

> **Step 1 (FIN)**: 클라이언트 ESTABLISHED → FIN_WAIT_1
> **Step 2 (ACK)**: 서버 ESTABLISHED → CLOSE_WAIT, 클라이언트 FIN_WAIT_1 → FIN_WAIT_2
> **Step 3 (FIN)**: 서버 CLOSE_WAIT → LAST_ACK
> **Step 4 (ACK)**: 클라이언트 FIN_WAIT_2 → TIME_WAIT → CLOSED, 서버 LAST_ACK → CLOSED
>
> 클라이언트는 TIME_WAIT에서 일정 시간(보통 2분) 대기 후 최종 CLOSED됩니다.

---

## 비교/구분

### Q6. 왜 연결은 3-way인데 종료는 4-way인가요?

> 연결할 때는 서버가 SYN과 ACK를 하나의 패킷으로 합쳐서 보낼 수 있습니다.
> 종료할 때는 클라이언트가 FIN을 보내도 서버는 아직 보낼 데이터가 남아있을 수 있습니다.
> 그래서 서버의 ACK(확인)과 FIN(종료)을 분리해서 보내야 하므로 4번이 됩니다.
> ACK와 FIN 사이에 서버가 남은 데이터를 전송하는 구간이 있기 때문입니다.

---

### Q7. 왜 2-way가 아니라 3-way handshake인가요?

> 양쪽이 서로 통신 가능함을 확인하려면 최소 3번이 필요합니다.
>
> 2-way라면 서버는 자신의 응답(SYN+ACK)이 클라이언트에 도달했는지 알 수 없습니다.
> 만약 오래 전에 보낸 SYN이 지연되어 뒤늦게 도착하면,
> 서버는 이미 무효화된 요청에 대해 연결을 열고 자원을 낭비합니다.
>
> 3번째 ACK이 있어야 서버가 "클라이언트가 진짜 연결 의사가 있다"를 확인할 수 있습니다.
> 즉, 3-way는 양방향 통신 확인을 위한 최소 횟수입니다.

---

### Q8. Half-Close란 무엇인가요?

> 한쪽만 연결을 닫고, 반대쪽은 아직 데이터를 보낼 수 있는 상태입니다.
> 4-way handshake에서 클라이언트가 FIN을 보내면:
> - 클라이언트 → 서버 방향은 닫힘 (클라이언트는 더 이상 데이터를 안 보냄)
> - 서버 → 클라이언트 방향은 열림 (서버는 아직 데이터를 보낼 수 있음)
>
> 서버가 남은 데이터를 다 보낸 후 FIN을 보내면 양쪽 모두 닫힙니다.
> 이것이 종료가 4-way인 이유입니다.

---

## 심화/실무

### Q9. TIME_WAIT 상태는 무엇이고, 왜 필요한가요?

> 4-way handshake 후 클라이언트가 바로 CLOSED가 아니라 일정 시간 대기하는 상태입니다.
> 두 가지 이유로 필요합니다.
>
> **1. 마지막 ACK 유실 대비**:
> 마지막 ACK가 유실되면 서버가 FIN을 재전송합니다.
> TIME_WAIT 중이어야 이 재전송에 다시 ACK를 보낼 수 있습니다.
>
> **2. 지연 패킷 방지**:
> 이전 연결의 패킷이 네트워크에서 지연되어 뒤늦게 도착할 수 있습니다.
> TIME_WAIT 동안 대기하면 이 패킷들이 소멸되어, 새 연결과 섞이지 않습니다.

---

### Q10. 서버에 TIME_WAIT이 대량으로 쌓이면 어떤 문제가 생기나요? 어떻게 해결하나요?

> TIME_WAIT 상태의 소켓이 수만 개 쌓이면 사용 가능한 포트가 부족해져
> 새로운 연결을 처리할 수 없게 됩니다.
>
> 해결 방법:
> - `SO_REUSEADDR` 소켓 옵션으로 TIME_WAIT 상태의 포트를 재사용
> - 커널 파라미터 `tcp_tw_reuse` 활성화
> - 로드 밸런서에서 연결을 관리하여 서버의 TIME_WAIT 부담 감소
> - HTTP Keep-Alive로 연결을 재사용하여 연결/종료 빈도 자체를 줄이기

---

### Q11. SYN Flooding 공격은 무엇이고, 어떻게 방어하나요?

> 공격자가 대량의 SYN 패킷만 보내고 3번째 ACK를 보내지 않는 공격입니다.
> 서버는 SYN_RECEIVED 상태의 연결을 계속 유지하며 자원을 소모합니다.
> 대기 큐가 가득 차면 정상 사용자의 연결 요청도 처리할 수 없게 됩니다.
>
> 방어 방법:
> - **SYN Cookie**: 서버가 상태를 저장하지 않고, ACK에 담긴 쿠키 값으로 검증
> - **방화벽/IDS**: 비정상적인 SYN 패킷 탐지 및 차단
> - **대기 큐 크기 증가**: backlog 파라미터 조정
> - **타임아웃 단축**: SYN_RECEIVED 대기 시간 줄이기

---

### Q12. CLOSE_WAIT 상태가 서버에 쌓이면 어떤 문제가 있나요? 원인은 무엇인가요?

> CLOSE_WAIT은 상대방이 FIN을 보냈는데 서버가 아직 FIN을 보내지 않은 상태입니다.
> 이것이 쌓이면 소켓 자원이 누수되어 결국 새 연결을 못 받게 됩니다.
>
> 원인은 대부분 **애플리케이션 버그**입니다.
> 서버 코드에서 소켓(또는 커넥션)을 제대로 close하지 않으면 FIN이 전송되지 않아
> CLOSE_WAIT 상태에 머물게 됩니다.
>
> TIME_WAIT은 OS가 자동 해제하지만, CLOSE_WAIT은 애플리케이션이 close해야만 해제됩니다.
> Spring Boot에서는 DB 커넥션, HTTP 클라이언트 등의 자원을 반드시 close해야 합니다.

---

## 꼬리질문

### Q13. 시퀀스 번호는 왜 0이 아니라 랜덤 값에서 시작하나요?

> 보안상의 이유입니다.
> 시퀀스 번호가 항상 0에서 시작하면, 공격자가 번호를 예측하여
> TCP 연결을 가로채거나(TCP Hijacking) 위조 패킷을 주입할 수 있습니다.
> 랜덤 초기 시퀀스 번호(ISN, Initial Sequence Number)를 사용하면
> 공격자가 유효한 시퀀스 번호를 추측하기 어려워집니다.
>
> 또한 이전 연결의 지연 패킷이 새 연결에서 유효한 패킷으로 오인되는 것도 방지합니다.

---

### Q14. HTTP Keep-Alive는 handshake와 어떤 관계가 있나요?

> HTTP Keep-Alive는 하나의 TCP 연결을 여러 HTTP 요청/응답에 재사용하는 기능입니다.
> Keep-Alive가 없으면 매 요청마다 3-way handshake(연결) + 4-way handshake(종료)를 해야 합니다.
>
> Keep-Alive를 쓰면 처음 한 번만 연결하고, 여러 요청을 처리한 후 마지막에 끊습니다.
> handshake 오버헤드를 크게 줄여 성능이 향상됩니다.
> HTTP/1.1부터 기본 활성화되어 있습니다.

---

### Q15. Spring Boot 서버에 사용자가 접속할 때 3-way handshake는 누가 처리하나요?

> 3-way handshake는 **OS 커널의 TCP 스택**이 처리합니다.
> Spring Boot(Tomcat)는 직접 handshake를 하지 않습니다.
>
> 흐름:
> 1. OS 커널이 포트 8080에서 SYN을 수신하고 SYN+ACK를 보냄
> 2. ACK를 받으면 연결 완료 (커널의 accept 큐에 넣음)
> 3. Tomcat의 스레드가 accept 큐에서 연결을 꺼내서 HTTP 요청을 처리
>
> 즉, TCP 연결 수립은 OS가, HTTP 처리는 Tomcat(Spring Boot)이 담당합니다.
