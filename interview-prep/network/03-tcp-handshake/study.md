# 3. TCP 3-way Handshake / 4-way Handshake

---

## 왜 Handshake가 필요한가?

TCP는 데이터를 보내기 전에 **"나 보낼 준비 됐어, 너도 받을 준비 됐어?"**를 확인한다.
이 과정이 Handshake(악수)다.

- 연결할 때: **3-way Handshake** (3번 주고받기)
- 끊을 때: **4-way Handshake** (4번 주고받기)

---

## 먼저 알아야 할 용어

| 용어 | 뜻 |
|------|-----|
| **SYN** | Synchronize. "연결하자!" 라는 신호 |
| **ACK** | Acknowledge. "알겠어, 확인했어" 라는 응답 |
| **FIN** | Finish. "끝내자!" 라는 신호 |
| **시퀀스 번호** | 패킷의 순서를 나타내는 번호 |

---

## 3-way Handshake (연결 수립)

클라이언트가 서버에 접속할 때 일어나는 과정이다.

```
  클라이언트                          서버
     |                                |
     |   1. SYN (seq=100)            |
     | ─────────────────────────────→ |
     |   "연결하고 싶어, 내 번호 100"   |
     |                                |
     |   2. SYN + ACK (seq=200,       |
     |      ack=101)                  |
     | ←───────────────────────────── |
     |   "좋아, 내 번호 200,           |
     |    너 100 잘 받았어(101 보내)"   |
     |                                |
     |   3. ACK (ack=201)             |
     | ─────────────────────────────→ |
     |   "너 200 잘 받았어(201 보내)"   |
     |                                |
     |   ===== 연결 완료 =====         |
```

### 각 단계 설명

**Step 1: SYN (클라이언트 → 서버)**
- 클라이언트가 서버에게 "연결하자"라고 요청
- 자기 시퀀스 번호(100)를 보냄
- 클라이언트 상태: `CLOSED` → `SYN_SENT`

**Step 2: SYN + ACK (서버 → 클라이언트)**
- 서버가 "좋아, 나도 연결할게"라고 응답
- 클라이언트의 SYN을 확인했다는 ACK(101) + 자기 시퀀스 번호(200)를 보냄
- 서버 상태: `LISTEN` → `SYN_RECEIVED`

**Step 3: ACK (클라이언트 → 서버)**
- 클라이언트가 서버의 SYN을 확인했다는 ACK(201)를 보냄
- 양쪽 모두 상태: `ESTABLISHED` (연결 완료!)

### 왜 2-way가 아니라 3-way인가? (면접 단골)

2-way라면:
```
클라이언트 → SYN → 서버    "나 보낼 준비 됐어"
클라이언트 ← ACK ← 서버    "알겠어"
```

이 경우 문제:
- 클라이언트는 "서버가 받을 준비 됐다"는 걸 안다
- 하지만 **서버는 "클라이언트가 내 응답을 받았는지" 모른다**

```
실제 문제 시나리오:

1. 클라이언트가 SYN을 보냄 (오래 전에)
2. 네트워크 지연으로 한참 뒤에 서버에 도착
3. 서버가 ACK를 보내고 연결 완료라고 생각
4. 클라이언트는 이미 그 연결을 포기한 상태
5. 서버만 혼자 연결을 유지 → 자원 낭비!
```

3-way면:
- 3번째 ACK이 와야 서버가 "클라이언트가 진짜 연결할 의사가 있구나" 확인
- **양쪽 모두** 상대방이 준비됐다는 것을 확인할 수 있다

> **정리**: 3-way는 클라이언트와 서버가 **서로** 통신 가능함을 확인하는 최소 횟수다.
> 클라이언트→서버 확인, 서버→클라이언트 확인, 양쪽 다 이 두 가지를 확인하려면 3번 필요.

---

## 4-way Handshake (연결 종료)

연결을 끊을 때는 4번 주고받는다.

```
  클라이언트                          서버
     |                                |
     |   1. FIN                       |
     | ─────────────────────────────→ |
     |   "나 이제 보낼 거 없어, 끊자"   |
     |                                |
     |   2. ACK                       |
     | ←───────────────────────────── |
     |   "알겠어, 근데 나 아직          |
     |    보낼 데이터 남았어, 잠깐"      |
     |                                |
     |   (서버가 남은 데이터 전송...)    |
     |                                |
     |   3. FIN                       |
     | ←───────────────────────────── |
     |   "나도 다 보냈어, 이제 끊자"    |
     |                                |
     |   4. ACK                       |
     | ─────────────────────────────→ |
     |   "알겠어, 끊자"               |
     |                                |
     |   ===== 연결 종료 =====        |
```

### 각 단계 설명

**Step 1: FIN (클라이언트 → 서버)**
- 클라이언트가 "나는 보낼 데이터가 없어, 끝내자"
- 클라이언트 상태: `ESTABLISHED` → `FIN_WAIT_1`

**Step 2: ACK (서버 → 클라이언트)**
- 서버가 "알겠어, 근데 나는 아직 보낼 게 있을 수 있어"
- 서버 상태: `ESTABLISHED` → `CLOSE_WAIT`
- 클라이언트 상태: `FIN_WAIT_1` → `FIN_WAIT_2`

**Step 3: FIN (서버 → 클라이언트)**
- 서버가 남은 데이터를 다 보낸 후 "나도 끝"
- 서버 상태: `CLOSE_WAIT` → `LAST_ACK`

**Step 4: ACK (클라이언트 → 서버)**
- 클라이언트가 "확인, 끊자"
- 서버 상태: `LAST_ACK` → `CLOSED`
- 클라이언트 상태: `FIN_WAIT_2` → `TIME_WAIT` → (일정 시간 후) `CLOSED`

### 왜 3-way가 아니라 4-way인가?

연결할 때는 서버가 SYN + ACK를 **한 번에** 보낼 수 있었다.

종료할 때는 안 된다:
- 클라이언트가 FIN을 보내도, **서버는 아직 보낼 데이터가 남아있을 수 있다**
- 그래서 ACK(알겠어)과 FIN(나도 끝)을 **따로** 보내야 한다
- 이걸 **Half-Close**라고 한다: 한쪽만 먼저 닫는 것

```
연결: SYN + ACK를 합칠 수 있음 → 3-way
종료: ACK와 FIN 사이에 데이터 전송이 있을 수 있음 → 4-way
```

---

## TIME_WAIT (면접에서 자주 물어봄)

4-way handshake 후 클라이언트는 바로 CLOSED가 아니라 **TIME_WAIT** 상태를 거친다.

```
클라이언트: FIN_WAIT_2 → TIME_WAIT → (보통 2분 대기) → CLOSED
```

### 왜 바로 안 닫을까?

**이유 1: 마지막 ACK 유실 대비**
```
클라이언트 → ACK → 서버
                   (만약 이 ACK가 유실되면?)
클라이언트 ← FIN ← 서버  (서버가 FIN을 재전송)
클라이언트 → ACK → 서버  (TIME_WAIT 중이니까 다시 ACK 보냄)
```

바로 닫으면 서버의 재전송 FIN에 응답할 수 없다.

**이유 2: 지연 패킷 처리**
```
이전 연결의 패킷이 네트워크에서 늦게 도착할 수 있다.
TIME_WAIT 동안 기다리면 이전 연결의 패킷이 모두 소멸된다.
새 연결이 이전 연결의 패킷과 섞이는 것을 방지.
```

### 서버에서 TIME_WAIT이 문제가 되는 경우

```
서버에 TIME_WAIT 소켓이 수만 개 쌓이면:
- 사용 가능한 포트가 부족해짐
- 새 연결을 못 받음
- 서버 성능 저하
```

해결법:
- `SO_REUSEADDR` 소켓 옵션 사용
- 커널 파라미터 조정 (`tcp_tw_reuse`)
- 로드 밸런서에서 연결 관리

---

## 전체 상태 변화 정리

### 연결 (3-way Handshake)

```
클라이언트: CLOSED → SYN_SENT → ESTABLISHED
서버:      LISTEN → SYN_RECEIVED → ESTABLISHED
```

### 종료 (4-way Handshake)

```
클라이언트: ESTABLISHED → FIN_WAIT_1 → FIN_WAIT_2 → TIME_WAIT → CLOSED
서버:      ESTABLISHED → CLOSE_WAIT → LAST_ACK → CLOSED
```

---

## Spring Boot 관점

```
1. 브라우저가 Spring Boot 서버(8080)에 접속

   [브라우저] ── 3-way handshake ──→ [Tomcat:8080]
   TCP 연결 완료

2. HTTP 요청/응답 (TCP 연결 위에서)

   [브라우저] ── GET /api/users ──→ [Spring Boot]
   [브라우저] ←── 200 OK + JSON ── [Spring Boot]

3. 연결 종료 (또는 Keep-Alive로 재사용)

   HTTP/1.1 Keep-Alive: 연결을 유지하여 여러 요청에 재사용
   → 매 요청마다 handshake 안 해도 됨 → 성능 향상
```

Keep-Alive가 중요한 이유:
- 3-way handshake는 시간이 걸린다
- 매 요청마다 하면 느리다
- 한 번 연결해두고 여러 요청을 보내는 게 효율적

---

## 면접 핵심 정리

**Q: TCP 3-way handshake를 설명해주세요**
> 클라이언트가 SYN을 보내고, 서버가 SYN+ACK로 응답하고,
> 클라이언트가 ACK를 보내면 연결이 완료됩니다.
> 이 과정을 통해 양쪽 모두 상대방과 통신 가능함을 확인합니다.

**Q: 왜 2-way가 아니라 3-way인가요?**
> 양쪽이 서로 데이터를 보내고 받을 수 있는지 확인하려면 최소 3번이 필요합니다.
> 2-way에서는 서버가 자신의 응답이 클라이언트에 도달했는지 확인할 수 없어서,
> 이미 무효화된 연결 요청에 서버가 자원을 낭비할 수 있습니다.

**Q: 4-way handshake는 왜 4번인가요?**
> 종료 시에는 한쪽이 FIN을 보내도 상대방은 아직 보낼 데이터가 남아있을 수 있습니다.
> 그래서 ACK(확인)과 FIN(종료)을 분리해서 보내야 하므로 4번이 됩니다.
> 이를 Half-Close라고 합니다.

**Q: TIME_WAIT은 왜 필요한가요?**
> 마지막 ACK가 유실될 경우 상대방의 FIN 재전송에 응답하기 위해서,
> 그리고 이전 연결의 지연 패킷이 새 연결과 섞이지 않도록 하기 위해서
> 일정 시간 대기합니다.
