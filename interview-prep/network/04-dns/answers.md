# DNS 면접 질문 + 답변

---

## 기본 개념

### Q1. DNS가 무엇이고, 왜 필요한가요?

> DNS(Domain Name System)는 도메인 이름을 IP 주소로 변환하는 시스템입니다.
> 사람은 google.com 같은 이름을 기억하지만, 컴퓨터는 142.250.207.46 같은 IP로 통신합니다.
> DNS는 이 둘을 연결해주는 인터넷의 전화번호부 역할을 합니다.
> DNS가 없으면 모든 웹사이트의 IP 주소를 외워야 합니다.

---

### Q2. 브라우저에 google.com을 입력하면 DNS 조회가 어떻게 이루어지나요?

> 1. **로컬 캐시 확인**: 브라우저 캐시 → OS 캐시 → hosts 파일 → 공유기 캐시 순서로 확인
> 2. **DNS Resolver에 질의**: 캐시에 없으면 ISP(KT, SKT 등)의 DNS Resolver에 요청
> 3. **계층적 탐색**: Resolver가 루트 DNS → .com TLD DNS → google.com 권한 DNS 순서로 질의
> 4. **결과 반환**: IP 주소를 받아 캐시에 저장하고, 브라우저에 전달
>
> 캐시에 있으면 1단계에서 바로 끝나고, 없으면 3단계까지 진행합니다.

---

### Q3. DNS의 계층 구조를 설명해주세요.

> DNS는 트리 형태의 3단계 계층 구조입니다.
>
> **루트 DNS 서버**: 최상위. 전 세계 13개 루트 서버가 있으며,
> 각 TLD 서버의 주소를 알고 있습니다.
>
> **TLD(Top-Level Domain) DNS 서버**: .com, .net, .kr 같은 최상위 도메인을 담당합니다.
> 해당 도메인 아래의 권한 DNS 서버 주소를 알고 있습니다.
>
> **권한(Authoritative) DNS 서버**: 실제 도메인의 IP 주소를 가지고 있습니다.
> google.com의 A 레코드(142.250.207.46)를 이 서버가 관리합니다.

---

### Q4. 재귀적 질의와 반복적 질의의 차이는 무엇인가요?

> **재귀적 질의(Recursive)**: 클라이언트가 DNS Resolver에게 "알아서 찾아줘"라고 요청합니다.
> Resolver가 대신 모든 과정을 처리하고 최종 결과만 돌려줍니다.
> 내 PC → DNS Resolver 구간이 재귀적 질의입니다.
>
> **반복적 질의(Iterative)**: DNS Resolver가 각 DNS 서버에 직접 물어봅니다.
> 각 서버는 답을 모르면 "나는 모르지만 다음 서버는 여기야"라고 알려줍니다.
> DNS Resolver → 루트/TLD/권한 DNS 구간이 반복적 질의입니다.
>
> 보통 클라이언트-Resolver는 재귀적, Resolver-DNS 서버는 반복적 질의를 사용합니다.

---

### Q5. DNS 레코드 타입 중 A, CNAME, MX를 설명해주세요.

> **A 레코드**: 도메인을 IPv4 주소에 직접 매핑합니다. 가장 기본적인 레코드입니다.
> 예: google.com → 142.250.207.46
>
> **CNAME 레코드**: 도메인을 다른 도메인에 매핑합니다(별칭).
> 예: www.google.com → google.com (www는 google.com의 별칭)
>
> **MX 레코드**: 메일 서버 주소를 지정합니다. 이메일 전송 시 사용됩니다.
> 예: google.com의 메일 → smtp.google.com

---

## 비교/구분

### Q6. A 레코드와 CNAME 레코드의 차이는 무엇인가요? 언제 어떤 걸 쓰나요?

> **A 레코드**는 도메인 → IP 주소 직접 매핑입니다.
> IP가 고정된 경우에 사용합니다.
>
> **CNAME**은 도메인 → 다른 도메인 매핑입니다.
> 로드 밸런서나 CDN처럼 IP가 변할 수 있는 경우에 유용합니다.
> CNAME으로 연결해두면 대상 도메인의 IP가 바뀌어도 자동으로 따라갑니다.
>
> 예: api.myapp.com → CNAME → my-load-balancer.aws.com → A → 실제 IP
> 로드 밸런서 IP가 바뀌어도 CNAME은 수정할 필요 없습니다.

---

### Q7. DNS 캐시는 어디에 존재하나요? 캐시가 왜 필요한가요?

> 4곳에 캐시가 존재합니다.
> 1. **브라우저 캐시**: 가장 먼저 확인, 가장 빠름
> 2. **OS 캐시**: 브라우저에 없으면 OS에서 확인
> 3. **공유기 캐시**: 같은 네트워크의 기기들이 공유
> 4. **DNS Resolver 캐시**: ISP 수준, 많은 사용자가 공유
>
> 캐시가 필요한 이유는 매번 루트 DNS부터 조회하면 느리기 때문입니다.
> 캐시 히트 시 DNS 조회 시간이 거의 0ms로 줄어듭니다.

---

### Q8. TTL이란 무엇이고, 길게/짧게 설정하면 각각 어떤 장단점이 있나요?

> TTL(Time To Live)은 DNS 레코드를 캐시에 유지하는 시간(초)입니다.
>
> **TTL이 길면 (예: 86400초 = 24시간)**:
> - 장점: 캐시 히트율 높아 DNS 조회 빠름, DNS 서버 부하 감소
> - 단점: IP가 변경되어도 TTL 만료까지 이전 IP로 접속 (반영 느림)
>
> **TTL이 짧으면 (예: 60초 = 1분)**:
> - 장점: IP 변경 시 빠르게 반영, 장애 시 빠른 전환 가능
> - 단점: DNS 조회 빈번, Resolver 부하 증가, 약간의 지연

---

## 심화/실무

### Q9. "브라우저에 URL을 입력하면 무슨 일이 일어나나요?" 전체 과정을 설명해주세요.

> 1. **URL 파싱**: 브라우저가 프로토콜(http), 도메인(myapp.com), 포트(8080), 경로(/api/users)를 분리
> 2. **DNS 조회**: myapp.com의 IP 주소를 찾음 (캐시 → DNS Resolver → 계층적 탐색)
> 3. **TCP 연결**: IP 주소로 3-way handshake 수행
> 4. **TLS 연결**: HTTPS라면 TLS handshake로 암호화 설정
> 5. **HTTP 요청**: GET /api/users 요청 전송
> 6. **서버 처리**: Spring Boot가 요청을 받아 처리
> 7. **HTTP 응답**: 서버가 200 OK + JSON 데이터 응답
> 8. **렌더링**: 브라우저가 응답을 화면에 표시
> 9. **연결 관리**: Keep-Alive로 연결 유지 또는 4-way handshake로 종료

---

### Q10. DNS가 서비스 성능에 미치는 영향은 무엇인가요? 어떻게 최적화하나요?

> 첫 접속 시 DNS 조회에 50~200ms가 소요될 수 있습니다.
> 이 시간은 사용자가 체감하는 첫 로딩 시간에 직접 영향을 줍니다.
>
> 최적화 방법:
> - **적절한 TTL 설정**: 자주 안 바뀌는 서비스는 TTL을 길게
> - **DNS Prefetch**: HTML에서 `<link rel="dns-prefetch">`로 미리 DNS 조회
> - **CDN 활용**: 사용자와 가까운 서버로 라우팅하여 DNS + 네트워크 지연 모두 감소
> - **빠른 DNS 서비스 사용**: Cloudflare(1.1.1.1), Google(8.8.8.8) 같은 고성능 DNS Resolver

---

### Q11. AWS Route 53 같은 DNS 서비스가 하는 일은 무엇인가요?

> Route 53은 권한(Authoritative) DNS 서버 역할을 합니다.
> 도메인의 DNS 레코드를 관리하고, DNS 질의에 응답합니다.
>
> 주요 기능:
> - **도메인 등록**: 도메인을 구매하고 관리
> - **DNS 레코드 관리**: A, CNAME, MX 등의 레코드 설정
> - **라우팅 정책**: 지역 기반, 가중치 기반, 장애 조치 등 트래픽 라우팅
> - **헬스 체크**: 서버 상태를 확인하고, 장애 시 자동으로 다른 서버로 전환
>
> Spring Boot 서버를 EC2에 배포하고 Route 53에서 myapp.com → EC2 IP를 설정하면
> 사용자가 myapp.com으로 접속할 수 있습니다.

---

### Q12. DNS Spoofing(위조) 공격은 무엇이고, 어떻게 방어하나요?

> DNS 응답을 위조하여 사용자를 가짜 서버로 유도하는 공격입니다.
> 예를 들어 bank.com의 DNS 응답을 조작하여 피싱 사이트의 IP를 돌려주면
> 사용자는 진짜 은행 사이트에 접속한 줄 알고 정보를 입력합니다.
>
> 방어 방법:
> - **DNSSEC**: DNS 응답에 디지털 서명을 추가하여 위조 여부 검증
> - **DoH(DNS over HTTPS)**: DNS 질의를 HTTPS로 암호화하여 중간 조작 방지
> - **DoT(DNS over TLS)**: DNS 질의를 TLS로 암호화
> - **신뢰할 수 있는 DNS 서버 사용**: ISP 기본 DNS 대신 보안이 검증된 서비스 사용

---

## 꼬리질문

### Q13. DNS는 TCP를 쓰나요, UDP를 쓰나요? 왜 그런가요?

> 기본적으로 **UDP**를 사용합니다.
> DNS 질의는 작은 데이터(보통 수백 바이트)를 한 번 주고받는 것이므로
> TCP처럼 연결을 맺는 오버헤드가 비효율적입니다.
>
> 단, 두 가지 경우에 TCP를 사용합니다:
> 1. DNS 응답이 512바이트를 초과하는 경우
> 2. DNS 영역 전송(Zone Transfer) - 서버 간 DNS 레코드 복제 시
>
> UDP 512바이트 제한이 있어 큰 응답은 TCP로 재시도합니다.

---

### Q14. hosts 파일은 무엇이고, DNS와 어떤 관계가 있나요?

> hosts 파일은 OS에 있는 도메인-IP 매핑 파일입니다.
> 위치: Linux/Mac은 `/etc/hosts`, Windows는 `C:\Windows\System32\drivers\etc\hosts`
>
> DNS 조회보다 먼저 확인됩니다 (브라우저 캐시 → OS 캐시 → **hosts** → DNS Resolver).
> hosts 파일에 매핑이 있으면 DNS 서버에 질의하지 않습니다.
>
> 개발 시 유용합니다:
> ```
> 127.0.0.1  myapp.local
> ```
> 이렇게 설정하면 myapp.local이 localhost로 연결되어 로컬 테스트에 활용할 수 있습니다.

---

### Q15. Spring Boot 서버를 배포할 때 DNS를 어떻게 설정하나요?

> 1. 도메인 구매 (예: myapp.com)
> 2. AWS Route 53 (또는 다른 DNS 서비스)에 호스팅 영역 생성
> 3. DNS 레코드 설정:
>    - 직접 배포: A 레코드로 myapp.com → EC2 IP
>    - 로드 밸런서 사용: CNAME으로 myapp.com → ALB 도메인
>    - api.myapp.com → CNAME → 로드 밸런서 (서브도메인 분리)
> 4. 도메인 등록기관에서 네임서버를 Route 53으로 변경
>
> 이후 사용자가 myapp.com으로 접속하면 DNS를 통해 서버 IP를 알아내고 연결합니다.
