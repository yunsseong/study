# HTTP/HTTPS 면접 질문 + 답변

---

## 기본 개념 (1~5)

### Q1. HTTP란 무엇이고, HTTP의 두 가지 특성(비연결성, 무상태)을 설명해주세요.

> HTTP(HyperText Transfer Protocol)는 웹에서 클라이언트와 서버가 데이터를 주고받기 위한 프로토콜입니다.
>
> **비연결성(Connectionless)**: 요청-응답이 끝나면 연결을 끊습니다.
> 서버 자원을 효율적으로 사용할 수 있지만, 매번 TCP 연결을 새로 맺어야 하는 오버헤드가 있습니다.
> HTTP/1.1부터 Keep-Alive로 연결을 재사용하여 이 단점을 보완합니다.
>
> **무상태(Stateless)**: 서버가 클라이언트의 이전 요청 정보를 기억하지 않습니다.
> 서버 확장(Scale-Out)이 쉬운 장점이 있지만, 매 요청마다 인증 정보를 보내야 합니다.
> 쿠키, 세션, JWT 등으로 상태를 유지할 수 있습니다.

---

### Q2. HTTP 무상태(Stateless)의 장점과 단점은 무엇이고, 단점을 어떻게 보완하나요?

> **장점**: 서버 확장이 쉽습니다.
> 서버가 클라이언트 상태를 저장하지 않으므로 어떤 서버가 요청을 받아도 동일하게 처리할 수 있습니다.
> 로드 밸런서 뒤에 서버를 여러 대 두고 수평 확장(Scale-Out)하기 용이합니다.
>
> **단점**: 로그인 같은 상태 유지가 필요한 기능을 HTTP만으로는 구현할 수 없습니다.
> 매 요청마다 "내가 누구인지" 알려줘야 합니다.
>
> **보완 방법**:
> - **쿠키 + 세션**: 서버에 세션을 저장하고, 쿠키로 세션 ID를 전달합니다.
>   단, 서버 확장 시 세션 공유 문제가 발생하여 Redis 등 별도 저장소가 필요합니다.
> - **JWT (JSON Web Token)**: 토큰 자체에 사용자 정보를 포함하여 서버가 상태를 저장할 필요 없습니다.
>   서버 확장에 유리하지만, 토큰 크기가 크고 강제 만료가 어렵습니다.

---

### Q3. HTTP 메서드 중 GET, POST, PUT, PATCH, DELETE의 역할과 멱등성을 설명해주세요.

> **GET**: 리소스를 조회합니다. 멱등합니다. 여러 번 요청해도 같은 결과를 반환합니다.
>
> **POST**: 리소스를 생성합니다. 멱등하지 않습니다. 요청할 때마다 새 리소스가 생성될 수 있습니다.
>
> **PUT**: 리소스를 전체 수정(덮어쓰기)합니다. 멱등합니다. 같은 데이터로 여러 번 수정해도 결과가 같습니다.
>
> **PATCH**: 리소스를 부분 수정합니다. 멱등합니다. 변경할 필드만 전송합니다.
>
> **DELETE**: 리소스를 삭제합니다. 멱등합니다. 이미 삭제된 리소스를 다시 삭제해도 결과는 "삭제됨"입니다.
>
> **멱등성(Idempotent)**이란 같은 요청을 여러 번 보내도 결과가 동일한 성질입니다.
> 네트워크 장애로 요청이 중복 전송될 수 있으므로, 멱등한 메서드는 안전하게 재시도할 수 있어 중요합니다.

---

### Q4. HTTP 상태 코드 401과 403의 차이는 무엇인가요?

> **401 Unauthorized**: 인증(Authentication)이 되지 않은 상태입니다.
> "너 누구야? 로그인부터 해"라는 의미입니다.
> 토큰이 없거나, 토큰이 만료되었거나, 잘못된 인증 정보를 보낸 경우에 반환합니다.
>
> **403 Forbidden**: 인증은 되었지만 권한(Authorization)이 없는 상태입니다.
> "너가 누군지는 알지만, 이 리소스에 접근할 권한은 없어"라는 의미입니다.
> 예를 들어 일반 사용자가 관리자 전용 API를 호출했을 때 반환합니다.
>
> 정리하면 401은 "신원 미확인", 403은 "신원은 확인했지만 권한 부족"입니다.

---

### Q5. HTTPS란 무엇이고, HTTP와 어떤 차이가 있나요?

> HTTPS는 HTTP에 TLS(Transport Layer Security)/SSL 암호화를 추가한 프로토콜입니다.
>
> HTTP는 데이터를 평문으로 전송하므로 중간에서 도청(스니핑), 변조가 가능합니다.
> HTTPS는 데이터를 암호화하여 전송하므로 중간에서 패킷을 가로채도 내용을 알 수 없습니다.
>
> 주요 차이:
> - **암호화**: HTTP는 평문, HTTPS는 TLS로 암호화
> - **포트**: HTTP는 80, HTTPS는 443
> - **인증서**: HTTPS는 SSL 인증서가 필요하며, CA(인증기관)를 통해 서버 신원을 검증
> - **성능**: HTTPS는 TLS Handshake로 인한 약간의 오버헤드가 있지만, HTTP/2.0과 함께 사용하면 오히려 더 빠를 수 있음
>
> 현재는 대부분의 웹사이트가 HTTPS를 사용하며, 검색 엔진도 HTTPS 사이트를 우대합니다.

---

## 비교/구분 (6~9)

### Q6. GET과 POST의 차이를 데이터 전달 방식, 캐시, 멱등성, 보안 관점에서 비교해주세요.

> **데이터 전달 방식**:
> GET은 URL 쿼리 스트링(`/users?name=kim`)에 데이터를 담아 전송합니다.
> POST는 요청 Body에 데이터를 담아 전송합니다.
>
> **캐시**:
> GET은 브라우저가 응답을 캐시할 수 있어, 동일한 요청 시 서버에 다시 요청하지 않을 수 있습니다.
> POST는 캐시되지 않습니다. 매번 서버에 요청을 보냅니다.
>
> **멱등성**:
> GET은 멱등합니다. 여러 번 요청해도 서버 상태가 변하지 않습니다.
> POST는 멱등하지 않습니다. 요청할 때마다 새로운 리소스가 생성될 수 있습니다.
>
> **보안**:
> GET은 URL에 데이터가 노출되어 브라우저 히스토리, 서버 로그에 남습니다.
> POST는 Body에 데이터가 포함되어 URL에는 노출되지 않습니다.
> 단, POST도 HTTPS 없이는 평문 전송이므로 진정한 보안은 HTTPS가 필요합니다.

---

### Q7. PUT과 PATCH의 차이는 무엇인가요? 실무에서 어떤 것을 더 많이 사용하나요?

> **PUT**: 리소스 전체를 교체(덮어쓰기)합니다.
> 모든 필드를 포함해서 보내야 하며, 빠진 필드는 null이 될 수 있습니다.
>
> ```
> PUT /users/1
> {"name": "kim", "age": 26, "email": "kim@test.com"}
> → 전체 필드를 보내야 안전
> ```
>
> **PATCH**: 리소스의 일부 필드만 수정합니다.
> 변경할 필드만 보내면 되고, 나머지는 기존 값을 유지합니다.
>
> ```
> PATCH /users/1
> {"age": 26}
> → age만 변경, name과 email은 그대로
> ```
>
> 실무에서는 **PATCH**를 더 많이 사용합니다.
> 매번 모든 필드를 보내는 것은 비효율적이고, 프론트엔드에서 변경된 필드만 전송하는 것이 자연스럽기 때문입니다.

---

### Q8. HTTP/1.1과 HTTP/2.0의 차이를 설명해주세요. HTTP/2.0이 해결한 문제는 무엇인가요?

> **HTTP/1.1의 문제점**:
> 하나의 TCP 연결에서 요청과 응답이 순차적으로 처리됩니다.
> HOL(Head-of-Line) Blocking 문제가 있어, 앞 요청이 느리면 뒤 요청도 지연됩니다.
> 매 요청마다 동일한 헤더를 중복 전송하여 대역폭이 낭비됩니다.
>
> **HTTP/2.0이 해결한 문제**:
>
> 1. **Multiplexing**: 하나의 TCP 연결에서 여러 요청/응답을 동시에 처리합니다.
>    스트림 단위로 독립적으로 전송되어 HOL Blocking을 애플리케이션 레벨에서 해결합니다.
>
> 2. **Header Compression (HPACK)**: 반복되는 헤더를 테이블로 관리하고 인덱스로 참조하여
>    헤더 크기를 대폭 줄입니다.
>
> 3. **Server Push**: 클라이언트가 요청하지 않은 리소스(CSS, JS 등)를 서버가 미리 전송하여
>    추가 요청 없이 리소스를 받을 수 있습니다.
>
> 4. **바이너리 프레이밍**: 텍스트가 아닌 바이너리로 데이터를 전송하여 파싱이 효율적입니다.

---

### Q9. 대칭키 암호화와 비대칭키 암호화의 차이는 무엇이고, HTTPS에서 둘을 어떻게 함께 사용하나요?

> **대칭키 암호화**: 암호화와 복호화에 동일한 키를 사용합니다.
> 연산이 빨라 대량 데이터 암호화에 적합하지만,
> 키를 상대방에게 안전하게 전달하는 것이 어렵습니다 (키가 노출되면 암호화가 무의미).
>
> **비대칭키 암호화**: 공개키와 개인키 쌍을 사용합니다.
> 공개키로 암호화하면 개인키로만 복호화할 수 있습니다.
> 키 교환 문제가 없지만, 연산이 느립니다 (대칭키 대비 100~1000배).
>
> **HTTPS에서의 결합 (하이브리드 방식)**:
> 1. TLS Handshake 과정에서 **비대칭키**로 안전하게 대칭키(세션키)를 교환합니다.
>    클라이언트가 Pre-Master Secret을 서버의 공개키로 암호화하여 전송합니다.
> 2. 이후 실제 데이터 통신은 교환한 **대칭키**로 암호화합니다.
>
> 이렇게 비대칭키의 안전한 키 교환과 대칭키의 빠른 암호화를 결합하여
> 보안성과 성능을 모두 확보합니다.

---

## 심화/실무 (10~12)

### Q10. HTTPS의 TLS Handshake 과정을 단계별로 설명해주세요.

> 1. **Client Hello**: 클라이언트가 지원하는 TLS 버전, 암호 알고리즘 목록, 클라이언트 랜덤값을 서버에 전송합니다.
>
> 2. **Server Hello**: 서버가 사용할 TLS 버전과 암호 알고리즘을 선택하고,
>    서버 랜덤값과 SSL 인증서(서버의 공개키 포함)를 클라이언트에 전송합니다.
>
> 3. **인증서 검증**: 클라이언트가 브라우저에 미리 설치된 CA(인증기관)의 공개키로
>    SSL 인증서의 디지털 서명을 검증하여 서버의 신원을 확인합니다.
>
> 4. **대칭키 교환**: 클라이언트가 Pre-Master Secret을 생성하고,
>    서버의 공개키로 암호화하여 전송합니다.
>    양쪽 모두 클라이언트 랜덤 + 서버 랜덤 + Pre-Master Secret을 조합하여
>    동일한 세션키(대칭키)를 생성합니다.
>
> 5. **Finished**: 양쪽이 "준비 완료" 메시지를 교환하고, 이후 모든 통신은 세션키로 암호화합니다.
>
> 핵심은 비대칭키로 안전하게 대칭키를 교환하고,
> 이후 빠른 대칭키로 실제 데이터를 암호화하는 하이브리드 방식입니다.

---

### Q11. HTTP/2.0의 Multiplexing, Header Compression, Server Push를 각각 설명해주세요.

> **Multiplexing (다중화)**:
> 하나의 TCP 연결 위에 여러 스트림을 만들어 요청과 응답을 동시에 주고받습니다.
> HTTP/1.1에서는 앞 요청의 응답을 기다려야 했지만(HOL Blocking),
> HTTP/2.0에서는 각 스트림이 독립적으로 전송되어 완성된 것부터 응답합니다.
> 브라우저가 도메인당 여러 TCP 연결을 여는 우회 방법이 더 이상 필요 없습니다.
>
> **Header Compression (HPACK)**:
> HTTP 요청에서 반복되는 헤더(Host, Accept, Authorization 등)를
> 정적/동적 테이블로 관리하고 인덱스 번호로 참조합니다.
> 첫 요청에서 전체 헤더를 보내고, 이후 동일한 헤더는 인덱스만 전송하여
> 헤더 크기를 대폭(85~88%) 줄입니다.
>
> **Server Push**:
> 클라이언트가 HTML을 요청하면, 서버가 HTML 안에서 참조하는 CSS, JS 파일을
> 클라이언트가 별도로 요청하기 전에 미리 전송합니다.
> 추가 요청-응답 왕복을 줄여 페이지 로딩 시간을 단축할 수 있습니다.

---

### Q12. Spring Boot에서 HTTPS를 적용하는 방법과 실무에서의 SSL Termination 패턴을 설명해주세요.

> **Spring Boot 직접 적용**:
> 1. SSL 인증서 파일(keystore.p12 등)을 준비합니다.
> 2. application.yml에서 `server.ssl` 설정으로 인증서 경로, 비밀번호, 타입을 지정합니다.
> 3. 포트를 443으로 설정하고, 필요시 HTTP(80) → HTTPS(443) 리다이렉트를 구성합니다.
>
> **실무에서의 SSL Termination 패턴**:
> 실무에서는 Spring Boot에 직접 SSL을 설정하기보다
> **Nginx, AWS ALB, API Gateway** 같은 앞단에서 SSL을 처리하는 패턴을 사용합니다.
>
> ```
> [클라이언트] --HTTPS--> [Nginx/ALB] --HTTP--> [Spring Boot]
>                         (SSL 처리)            (내부 통신)
> ```
>
> 이 방식의 장점:
> - Spring Boot 서버의 SSL 처리 부담을 줄여 성능 향상
> - 인증서 관리를 한 곳에서 통합 가능
> - 서버 여러 대를 운영할 때 인증서를 각각 설치할 필요 없음
> - 내부 네트워크에서는 HTTP로 통신하므로 디버깅이 쉬움

---

## 꼬리질문 대비 (13~15)

### Q13. HTTP/2.0에서도 HOL Blocking 문제가 완전히 해결되지 않았다고 하는데, 왜 그런가요? HTTP/3.0은 이를 어떻게 해결하나요?

> HTTP/2.0은 애플리케이션 레벨에서는 Multiplexing으로 HOL Blocking을 해결했지만,
> **TCP 레벨의 HOL Blocking**은 여전히 존재합니다.
>
> TCP는 패킷의 순서를 보장하므로, 하나의 TCP 연결에서 패킷이 하나라도 유실되면
> 해당 패킷이 재전송될 때까지 모든 스트림의 데이터 전달이 차단됩니다.
> 스트림 A의 패킷이 유실되면 스트림 B, C도 함께 대기해야 합니다.
>
> **HTTP/3.0(QUIC)**은 TCP 대신 UDP 기반의 QUIC 프로토콜을 사용하여 이 문제를 해결합니다.
> QUIC에서는 각 스트림이 독립적으로 동작하므로,
> 스트림 A에서 패킷이 유실되어도 스트림 B, C는 영향 없이 계속 데이터를 수신합니다.
> 또한 연결 설정도 1-RTT(재연결 시 0-RTT)로 더 빠릅니다.

---

### Q14. HTTP 캐시는 어떻게 동작하나요? Cache-Control 헤더와 304 상태 코드의 관계를 설명해주세요.

> **HTTP 캐시 동작 방식**:
> 서버가 응답에 `Cache-Control` 헤더를 포함하여 캐시 정책을 지시합니다.
>
> - `Cache-Control: max-age=3600` → 3600초(1시간) 동안 캐시 사용, 서버에 다시 요청하지 않음
> - `Cache-Control: no-cache` → 캐시를 저장하되, 사용 전 반드시 서버에 유효성 검증
> - `Cache-Control: no-store` → 캐시를 아예 저장하지 않음
>
> **304 Not Modified와의 관계**:
> `max-age`가 만료되었거나 `no-cache`인 경우, 브라우저는 서버에 조건부 요청을 보냅니다.
>
> 1. 브라우저가 `If-None-Match: "etag값"` 또는 `If-Modified-Since: 날짜` 헤더를 포함하여 요청
> 2. 서버가 리소스가 변경되지 않았으면 **304 Not Modified** (Body 없이) 응답
> 3. 브라우저는 기존 캐시를 그대로 사용 → 네트워크 대역폭 절약
> 4. 리소스가 변경되었으면 **200 OK**와 함께 새 데이터 응답
>
> 이를 통해 변경 없는 리소스의 불필요한 재전송을 방지합니다.

---

### Q15. SSL 인증서는 무엇이고, 브라우저는 인증서를 어떻게 검증하나요?

> **SSL 인증서**:
> 서버의 신원을 증명하는 디지털 문서입니다.
> CA(Certificate Authority, 인증기관)라는 신뢰할 수 있는 제3자가 발급합니다.
> 인증서에는 서버 도메인, 서버의 공개키, CA 정보, CA의 디지털 서명, 유효 기간이 포함됩니다.
>
> **브라우저의 검증 과정**:
>
> 1. **인증서 수신**: TLS Handshake 중 서버가 SSL 인증서를 전달합니다.
>
> 2. **서명 검증**: 브라우저에는 신뢰할 수 있는 CA의 공개키가 미리 설치되어 있습니다.
>    이 공개키로 인증서의 디지털 서명을 복호화하여 위조 여부를 확인합니다.
>
> 3. **인증서 체인 확인**: 인증서는 Root CA → Intermediate CA → 서버 인증서의 체인 구조입니다.
>    브라우저가 Root CA까지 체인을 따라가며 신뢰 여부를 확인합니다.
>
> 4. **도메인 확인**: 인증서에 기재된 도메인이 접속한 도메인과 일치하는지 확인합니다.
>
> 5. **유효 기간 확인**: 인증서가 만료되지 않았는지 확인합니다.
>
> 검증에 실패하면 브라우저가 "이 연결은 안전하지 않습니다" 경고를 표시합니다.
