# 프로세스와 스레드 면접 질문 + 답변

---

## 기본 개념

### Q1. 프로세스와 스레드의 차이점을 설명해주세요.

> 프로세스는 실행 중인 프로그램으로 독립적인 메모리 공간을 가지며, 스레드는 프로세스 내에서 실행되는 작업 단위로 같은 프로세스의 스레드끼리는 메모리를 공유합니다. 프로세스는 최소 하나의 스레드(메인 스레드)를 가지며, 프로세스 간 통신은 IPC를 사용해야 하지만 스레드 간 통신은 공유 메모리를 통해 쉽게 가능합니다. 다만 스레드는 메모리를 공유하기 때문에 동기화 문제가 발생할 수 있습니다.

---

### Q2. 프로세스의 메모리 구조(Code, Data, Heap, Stack)를 설명하고, 각 영역의 역할을 말씀해주세요.

> Code 영역은 실행할 프로그램의 코드가 저장되며 읽기 전용입니다. Data 영역은 전역 변수와 정적 변수가 저장되고 프로그램 시작 시 할당됩니다. Heap 영역은 동적 할당(new, malloc)되는 메모리로 런타임에 크기가 결정되며 낮은 주소에서 높은 주소로 증가합니다. Stack 영역은 함수 호출 시 지역 변수와 매개변수가 저장되며 높은 주소에서 낮은 주소로 증가합니다. 스레드는 Stack만 독립적으로 가지고 나머지는 공유합니다.

---

### Q3. PCB(Process Control Block)가 무엇이며, 어떤 정보를 담고 있나요?

> PCB는 운영체제가 프로세스를 관리하기 위해 유지하는 자료구조입니다. 프로세스 ID(PID), 프로세스 상태(ready, running, waiting 등), 프로그램 카운터(PC), CPU 레지스터 값, 메모리 관리 정보, 스케줄링 정보, I/O 상태 정보 등을 포함합니다. 컨텍스트 스위칭 발생 시 현재 프로세스의 상태를 PCB에 저장하고, 다음 프로세스의 PCB를 복원하여 실행을 재개합니다.

---

### Q4. 컨텍스트 스위칭(Context Switching)이 무엇이고, 왜 오버헤드가 발생하나요?

> 컨텍스트 스위칭은 CPU가 현재 실행 중인 프로세스(또는 스레드)를 중단하고 다른 프로세스로 전환하는 과정입니다. 현재 프로세스의 레지스터, PC 등의 상태를 PCB에 저장하고, 새로운 프로세스의 PCB를 로드하여 CPU 레지스터를 복원합니다. 이 과정에서 CPU가 실제 작업을 수행하지 못하고, 캐시 메모리가 무효화되며, TLB가 플러시되기 때문에 오버헤드가 발생합니다. 스레드 간 컨텍스트 스위칭이 프로세스보다 빠른 이유는 메모리 공간을 공유하기 때문입니다.

---

### Q5. IPC(Inter-Process Communication)의 주요 방법들을 설명해주세요.

> 파이프(Pipe)는 단방향 통신으로 부모-자식 프로세스 간 사용되며, Named Pipe는 이름이 있어 무관한 프로세스도 통신 가능합니다. 메시지 큐(Message Queue)는 메시지 단위로 데이터를 주고받으며 비동기 통신이 가능합니다. 공유 메모리(Shared Memory)는 가장 빠른 IPC로 여러 프로세스가 같은 메모리 영역에 접근하지만 동기화가 필요합니다. 소켓(Socket)은 네트워크를 통한 프로세스 간 통신에 사용되며, 시그널(Signal)은 이벤트 발생을 알리는 비동기 메커니즘입니다.

---

## 비교/구분

### Q6. 멀티프로세스와 멀티스레드의 차이점과 각각의 장단점을 설명해주세요.

> 멀티프로세스는 각 프로세스가 독립적인 메모리를 가져 안정성이 높고 하나의 프로세스가 죽어도 다른 프로세스에 영향을 주지 않지만, 메모리 사용량이 많고 컨텍스트 스위칭 비용이 큽니다. 멀티스레드는 메모리를 공유하여 자원 효율적이고 컨텍스트 스위칭이 빠르며 데이터 공유가 쉽지만, 하나의 스레드 오류가 전체 프로세스에 영향을 주고 동기화 문제(Race Condition, Deadlock)가 발생할 수 있습니다. Chrome은 안정성을 위해 멀티프로세스를, 웹 서버는 효율성을 위해 멀티스레드를 주로 사용합니다.

---

### Q7. 프로세스 간 메모리 공유가 불가능한 이유와, 스레드는 어떤 자원을 공유하나요?

> 프로세스는 운영체제의 메모리 보호 기법으로 독립적인 가상 주소 공간을 가지며, 다른 프로세스의 메모리에 접근하면 세그멘테이션 폴트가 발생합니다. 이는 프로세스 간 격리를 통해 안정성과 보안을 보장하기 위함입니다. 반면 스레드는 같은 프로세스 내에서 Code, Data, Heap 영역을 공유하고, 파일 디스크립터, 전역 변수, 동적 할당 메모리를 공유합니다. 다만 각 스레드는 독립적인 Stack, 레지스터, PC를 가져 독립적인 실행 흐름을 유지합니다.

---

### Q8. 사용자 수준 스레드(User-level Thread)와 커널 수준 스레드(Kernel-level Thread)의 차이를 설명해주세요.

> 사용자 수준 스레드는 커널이 인식하지 못하고 사용자 공간의 라이브러리가 관리하므로 컨텍스트 스위칭이 빠르고 유연하지만, 하나의 스레드가 블로킹되면 전체 프로세스가 블로킹되며 멀티코어를 활용하지 못합니다. 커널 수준 스레드는 운영체제가 직접 관리하여 멀티코어 활용이 가능하고 하나의 스레드 블로킹이 다른 스레드에 영향을 주지 않지만, 컨텍스트 스위칭 시 모드 전환(사용자 모드 ↔ 커널 모드)으로 오버헤드가 큽니다. 현대 운영체제는 주로 커널 수준 스레드를 사용합니다.

---

### Q9. Chrome 브라우저는 멀티프로세스 방식을, 일반적인 웹 서버는 멀티스레드 방식을 사용합니다. 그 이유는 무엇인가요?

> Chrome은 각 탭을 별도 프로세스로 실행하여 하나의 탭이 크래시되어도 다른 탭에 영향을 주지 않고, 악성 코드로부터 격리를 보장하며, 무응답 탭을 강제 종료할 수 있어 안정성을 높입니다. 메모리 사용량은 증가하지만 사용자 경험을 우선합니다. 웹 서버는 대량의 요청을 효율적으로 처리하기 위해 멀티스레드를 사용하며, 스레드 풀을 통해 메모리 사용을 최소화하고 빠른 응답 속도를 제공합니다. Spring Boot의 Tomcat도 스레드 풀 기반 멀티스레드 방식을 사용합니다.

---

## 심화/실무

### Q10. Spring Boot의 Tomcat은 요청을 어떻게 처리하나요? 스레드 풀의 동작 원리를 설명해주세요.

> Tomcat은 기본적으로 스레드 풀을 사용하여 요청을 처리합니다. 클라이언트 요청이 들어오면 Acceptor 스레드가 연결을 수락하고, 스레드 풀에서 유휴 스레드를 할당하여 요청을 처리합니다. 기본 설정은 최소 10개, 최대 200개의 스레드를 유지하며, 모든 스레드가 사용 중이면 요청은 큐에 대기합니다. 큐도 가득 차면 요청을 거부합니다. 이 방식은 매 요청마다 스레드를 생성/삭제하는 오버헤드를 줄이고, 시스템 자원을 효율적으로 사용합니다. application.properties에서 server.tomcat.threads.max로 설정 가능합니다.

---

### Q11. Java의 Virtual Thread(Project Loom)가 기존 Platform Thread와 어떻게 다르며, 어떤 문제를 해결하나요?

> Platform Thread는 OS 스레드와 1:1 매핑되어 무겁고 생성 비용이 높아 수천 개 이상 생성하기 어렵습니다. Virtual Thread는 JVM이 관리하는 경량 스레드로 수백만 개도 생성 가능하며, 내부적으로 소수의 Platform Thread(Carrier Thread)에서 실행됩니다. I/O 작업 시 블로킹되지 않고 다른 Virtual Thread로 전환(마운트/언마운트)하여 CPU를 효율적으로 사용합니다. 기존에는 스레드 풀 크기 제한으로 동시성 처리에 한계가 있었지만, Virtual Thread는 요청마다 스레드를 생성해도 문제없어 코드를 동기식으로 작성하면서도 높은 동시성을 달성합니다.

---

### Q12. 대용량 트래픽 처리를 위해 멀티프로세스와 멀티스레드 중 어떤 방식을 선택하시겠습니까? 그 이유는?

> 멀티스레드 방식을 선택합니다. 웹 애플리케이션은 대부분 I/O 바운드 작업이므로 메모리를 공유하는 멀티스레드가 효율적이고, 컨텍스트 스위칭 비용이 낮아 더 많은 요청을 처리할 수 있습니다. 스레드 풀을 통해 스레드 생성/삭제 오버헤드를 줄이고, Spring Boot의 비동기 처리(@Async), 리액티브 프로그래밍(WebFlux), 또는 Virtual Thread를 활용하면 더 높은 동시성을 달성할 수 있습니다. 다만 CPU 집약적 작업이나 격리가 중요한 경우(컨테이너 환경)에는 멀티프로세스가 유리할 수 있습니다.

---

## 꼬리질문

### Q13. 스레드는 독립적인 Stack을 가지는데, 왜 Heap은 공유하나요?

> Stack은 함수 호출과 지역 변수를 저장하는 영역으로, 각 스레드가 독립적인 실행 흐름을 가지려면 별도의 Stack이 필요합니다. 만약 Stack을 공유하면 함수 호출 순서가 꼬이고 지역 변수가 덮어씌워져 정상 실행이 불가능합니다. 반면 Heap은 동적 할당 메모리로, 스레드 간 데이터를 공유하기 위해 공유됩니다. 예를 들어 Java에서 new로 생성한 객체는 Heap에 저장되고, 여러 스레드가 같은 객체에 접근하여 협력 작업을 수행할 수 있습니다. 다만 동기화가 필요합니다.

---

### Q14. 프로세스를 생성하는 fork()와 exec()의 차이는 무엇인가요?

> fork()는 현재 프로세스를 복제하여 자식 프로세스를 생성하며, 부모와 자식은 같은 코드를 실행하지만 독립적인 메모리 공간을 가집니다. fork() 이후 부모는 자식의 PID를 반환받고, 자식은 0을 반환받아 서로 다른 작업을 수행할 수 있습니다. exec()는 현재 프로세스의 메모리를 새로운 프로그램으로 대체하여 완전히 다른 프로그램을 실행합니다. 일반적으로 fork()로 자식 프로세스를 만든 후 exec()를 호출하여 새로운 프로그램을 실행하는 패턴을 사용합니다(예: 쉘에서 명령어 실행).

---

### Q15. Spring Boot 애플리케이션에서 @Async를 사용할 때 스레드는 어떻게 관리되나요?

> @Async는 메서드를 비동기로 실행하며, 기본적으로 SimpleAsyncTaskExecutor를 사용하여 매번 새로운 스레드를 생성합니다. 이는 대량 요청 시 스레드 고갈을 일으킬 수 있으므로, ThreadPoolTaskExecutor를 빈으로 등록하여 스레드 풀을 사용하는 것이 권장됩니다. 스레드 풀 설정으로 corePoolSize(최소 스레드), maxPoolSize(최대 스레드), queueCapacity(큐 크기)를 지정할 수 있습니다. 모든 스레드가 사용 중이면 큐에 대기하고, 큐도 가득 차면 RejectedExecutionException이 발생합니다. @EnableAsync로 활성화합니다.
