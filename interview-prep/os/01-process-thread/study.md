# 1. 프로세스와 스레드

---

## 프로그램 vs 프로세스

**프로그램**: 디스크에 저장된 실행 파일. 아직 실행되지 않은 상태.
```
예: /usr/bin/java (그냥 파일)
```

**프로세스**: 프로그램이 메모리에 올라와 **실행 중인** 상태.
```
예: java -jar myapp.jar 실행 → 프로세스가 됨
```

> IntelliJ에서 Spring Boot를 "Run" 하면 → Java 프로그램이 프로세스가 됨

---

## 프로세스 구조

프로세스는 메모리에 올라오면 다음과 같은 영역을 가진다:

```
┌──────────────────┐ 높은 주소
│     Stack        │ ← 함수 호출, 지역 변수 (위에서 아래로 자람)
│        ↓         │
│                  │
│        ↑         │
│     Heap         │ ← 동적 할당 (new, malloc) (아래에서 위로 자람)
├──────────────────┤
│     Data         │ ← 전역 변수, static 변수
├──────────────────┤
│     Code(Text)   │ ← 실행할 코드 (명령어)
└──────────────────┘ 낮은 주소
```

| 영역 | 저장하는 것 | Java 예시 |
|------|-----------|----------|
| **Code** | 실행할 명령어 | 컴파일된 바이트코드 |
| **Data** | 전역/static 변수 | `static int count = 0;` |
| **Heap** | 동적 할당 객체 | `new User()`, `new ArrayList()` |
| **Stack** | 지역 변수, 함수 호출 | 메서드 내 `int x = 10;` |

---

## 프로세스 상태

프로세스는 5가지 상태를 가진다:

```
        생성
         │
         ↓
      [New] ──→ [Ready] ←──┐
                  │         │
           스케줄링│         │ 타이머 인터럽트
                  ↓         │
              [Running] ────┘
                  │
         ┌───────┴───────┐
         ↓               ↓
    [Blocked/         [Terminated]
     Waiting]             종료
    (I/O 대기)
         │
         └──→ [Ready]
              I/O 완료
```

| 상태 | 의미 |
|------|------|
| **New** | 프로세스 생성 중 |
| **Ready** | CPU를 기다리는 중 (실행 준비 완료) |
| **Running** | CPU에서 실행 중 |
| **Blocked(Waiting)** | I/O 등 외부 이벤트 대기 중 |
| **Terminated** | 실행 완료 |

---

## PCB (Process Control Block)

OS가 프로세스를 관리하기 위해 저장하는 정보. 프로세스마다 1개씩 있다.

```
PCB에 들어있는 것:
- 프로세스 ID (PID)
- 프로세스 상태 (Running, Ready 등)
- 프로그램 카운터 (다음에 실행할 명령어 주소)
- CPU 레지스터 값들
- 메모리 관리 정보 (페이지 테이블 등)
- 열린 파일 목록
- 스케줄링 정보 (우선순위 등)
```

> **왜 중요한가?**: 컨텍스트 스위칭 할 때 현재 프로세스의 PCB에 상태를 저장하고,
> 다음 프로세스의 PCB에서 상태를 복원한다.

---

## 스레드 (Thread)

### 스레드란?

프로세스 내에서 실행되는 **더 작은 실행 단위**.
하나의 프로세스는 여러 스레드를 가질 수 있다.

```
[프로세스]
├── 스레드 1 (main)
├── 스레드 2 (요청 처리)
└── 스레드 3 (백그라운드 작업)
```

### 프로세스 vs 스레드 메모리 구조

**프로세스**: 각자 독립된 메모리 공간

```
[프로세스 A]              [프로세스 B]
┌──────────┐             ┌──────────┐
│  Stack   │             │  Stack   │
│  Heap    │  ← 독립 →  │  Heap    │
│  Data    │             │  Data    │
│  Code    │             │  Code    │
└──────────┘             └──────────┘
서로 메모리 접근 불가
```

**스레드**: 같은 프로세스 내에서 Code, Data, Heap 공유

```
[프로세스]
┌─────────────────────────────┐
│  Code (공유)                │
│  Data (공유)                │
│  Heap (공유)                │
├─────────────────────────────┤
│ Stack1 │ Stack2 │ Stack3    │  ← 각 스레드마다 별도
└─────────────────────────────┘
```

| 항목 | 프로세스 | 스레드 |
|------|---------|--------|
| 메모리 | 독립 | Code, Data, Heap **공유** |
| 생성 비용 | 크다 | 작다 |
| 통신 | IPC 필요 (복잡) | 공유 메모리로 직접 통신 (쉬움) |
| 안정성 | 하나 죽어도 다른 프로세스 무관 | 하나 죽으면 전체 프로세스 영향 |
| 컨텍스트 스위칭 | 느림 (메모리 교체) | 빠름 (Stack만 교체) |

---

## 컨텍스트 스위칭 (Context Switching)

CPU가 실행 중인 프로세스/스레드를 바꾸는 것.

### 프로세스 컨텍스트 스위칭

```
[프로세스 A 실행 중]
    │
    │ ① 프로세스 A의 상태를 PCB_A에 저장
    │   (레지스터, 프로그램 카운터, 메모리 정보)
    │
    │ ② 프로세스 B의 PCB_B에서 상태 복원
    │
[프로세스 B 실행 시작]
```

**비용이 큰 이유**:
- PCB 저장/복원
- 메모리 주소 공간 교체 (페이지 테이블 교체)
- CPU 캐시 무효화 (캐시 미스 증가)
- TLB(Translation Lookaside Buffer) 플러시

### 스레드 컨텍스트 스위칭

```
같은 프로세스 내 스레드 전환:
- Stack과 레지스터만 교체
- 메모리 주소 공간은 그대로 (Code, Data, Heap 공유)
- 캐시도 대부분 유효
→ 프로세스 전환보다 훨씬 빠름
```

> **면접 포인트**: "스레드 컨텍스트 스위칭이 프로세스보다 빠른 이유는?"
> → 메모리 주소 공간을 교체하지 않고, 공유 자원은 그대로 사용하기 때문입니다.

---

## 멀티 프로세스 vs 멀티 스레드

### 멀티 프로세스

하나의 프로그램을 **여러 프로세스**로 실행.

```
[Chrome]
├── 탭 1 (프로세스)
├── 탭 2 (프로세스)
└── 탭 3 (프로세스)

장점: 탭 1이 죽어도 탭 2, 3은 살아있음
단점: 메모리 많이 사용, 프로세스 간 통신(IPC) 복잡
```

### 멀티 스레드

하나의 프로세스 안에서 **여러 스레드**로 실행.

```
[Spring Boot 서버]
├── 스레드 1: GET /api/users 처리
├── 스레드 2: POST /api/orders 처리
└── 스레드 3: GET /api/products 처리

장점: 메모리 절약 (공유), 통신 쉬움, 생성 빠름
단점: 하나의 스레드 오류가 전체에 영향, 동기화 문제
```

---

## Spring Boot와 스레드

### Tomcat 스레드 풀

```
Spring Boot 내장 Tomcat:
- 기본 스레드 풀 크기: 200개
- 요청이 오면 스레드 풀에서 스레드 1개를 할당
- 요청 처리 후 스레드를 풀에 반환

설정:
server.tomcat.threads.max=200      # 최대 스레드 수
server.tomcat.threads.min-spare=10 # 최소 유지 스레드 수
```

### 왜 스레드 풀을 쓸까?

```
스레드 풀 없이:
요청마다 new Thread() → 생성 비용 → 처리 → 제거 비용
1000개 요청 → 1000개 스레드 생성/제거 → 오버헤드 심각

스레드 풀 사용:
미리 200개 생성해놓고 재사용
요청 → 풀에서 스레드 꺼냄 → 처리 → 풀에 반환
생성/제거 비용 없음 → 성능 향상
```

### Java 21 Virtual Thread

기존 스레드(Platform Thread)는 OS 스레드와 1:1 매핑이라 무겁다.
Java 21의 Virtual Thread는 **경량 스레드**로, OS 스레드 위에 여러 개가 올라간다.

```
기존: 1 요청 = 1 Platform Thread = 1 OS Thread (무거움)
신규: 1 요청 = 1 Virtual Thread, 여러 VT가 적은 수의 OS Thread를 공유 (가벼움)
```

> 면접에서 "Java 21 Virtual Thread 알아요?"에 간단히 답할 수 있으면 차별화됩니다.

---

## IPC (Inter-Process Communication)

프로세스 간 통신 방법. 프로세스는 메모리가 독립이라 직접 통신이 안 된다.

| 방법 | 설명 | 예시 |
|------|------|------|
| **파이프** | 단방향/양방향 데이터 스트림 | `ls \| grep txt` |
| **메시지 큐** | 메시지를 큐에 넣고 꺼냄 | POSIX message queue |
| **공유 메모리** | 메모리 영역을 공유 | 가장 빠름, 동기화 필요 |
| **소켓** | 네트워크 통신 | Spring Boot ↔ MySQL (TCP 소켓) |
| **시그널** | 특정 이벤트 알림 | `kill -9 PID` |

> **면접 포인트**: "프로세스는 IPC가 필요하지만 스레드는 공유 메모리로 직접 통신 가능"
> → 이것이 멀티 스레드의 장점

---

## 면접 핵심 정리

**Q: 프로세스와 스레드의 차이를 설명해주세요**
> 프로세스는 독립된 메모리 공간(Code, Data, Heap, Stack)을 가진 실행 단위이고,
> 스레드는 프로세스 내에서 Code, Data, Heap을 공유하며 Stack만 별도로 가진 실행 단위입니다.
> 스레드는 공유 자원 덕분에 생성 비용과 컨텍스트 스위칭 비용이 프로세스보다 작습니다.

**Q: 컨텍스트 스위칭이 왜 비용이 드나요?**
> PCB에 현재 상태를 저장하고 다음 프로세스의 상태를 복원해야 합니다.
> 특히 프로세스 전환 시 메모리 주소 공간(페이지 테이블)을 교체해야 하고,
> CPU 캐시와 TLB가 무효화되어 캐시 미스가 증가합니다.
> 스레드 전환은 같은 메모리 공간을 사용하므로 이런 비용이 없어 훨씬 빠릅니다.

**Q: Spring Boot는 멀티 프로세스? 멀티 스레드?**
> 멀티 스레드입니다. 내장 Tomcat이 스레드 풀(기본 200개)을 관리하고,
> 요청마다 스레드를 할당하여 처리합니다.
> 스레드 풀을 쓰는 이유는 매번 스레드를 생성/제거하는 비용을 줄이기 위해서입니다.
