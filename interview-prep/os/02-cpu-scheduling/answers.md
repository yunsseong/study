# CPU 스케줄링 면접 질문 + 답변

---

## 기본 개념

### Q1. CPU 스케줄링이 왜 필요한가요?

> CPU는 하나(또는 제한된 개수)이지만 실행할 프로세스는 여러 개이므로, 어떤 프로세스에 CPU를 할당할지 결정해야 합니다. 효율적인 스케줄링을 통해 CPU 이용률을 높이고, 대기 시간을 줄이며, 응답 시간을 개선하고, 처리량을 증가시킬 수 있습니다. 또한 멀티프로그래밍 환경에서 공정성을 보장하고, 시스템 자원을 최적으로 활용하여 전체 시스템 성능을 향상시킵니다.

---

### Q2. 선점(Preemptive) 스케줄링과 비선점(Non-preemptive) 스케줄링의 차이를 설명해주세요.

> 선점 스케줄링은 실행 중인 프로세스를 강제로 중단시키고 다른 프로세스에 CPU를 할당할 수 있습니다. 응답 시간이 빠르고 공정성이 높지만 컨텍스트 스위칭 오버헤드가 발생합니다. Round Robin, SRTF, Priority(선점형)가 대표적입니다. 비선점 스케줄링은 실행 중인 프로세스가 자발적으로 CPU를 반납할 때까지 기다리며, 컨텍스트 스위칭이 적지만 응답 시간이 길어질 수 있습니다. FCFS, SJF, Priority(비선점형)가 대표적입니다.

---

### Q3. CPU 스케줄링의 성능 지표(평균 대기 시간, 평균 반환 시간, 처리량, 응답 시간)를 설명해주세요.

> 평균 대기 시간(Average Waiting Time)은 프로세스가 Ready Queue에서 대기한 시간의 평균으로, 짧을수록 좋습니다. 평균 반환 시간(Average Turnaround Time)은 프로세스가 도착해서 완료될 때까지의 시간(대기 시간 + 실행 시간)으로, 짧을수록 좋습니다. 처리량(Throughput)은 단위 시간당 완료된 프로세스 수로, 높을수록 좋습니다. 응답 시간(Response Time)은 요청 후 첫 응답까지의 시간으로, 대화형 시스템에서 중요하며 짧을수록 좋습니다.

---

### Q4. 기아(Starvation) 현상이 무엇이고, 어떻게 해결할 수 있나요?

> 기아 현상은 특정 프로세스가 우선순위가 낮거나 계속 새로운 프로세스가 들어와서 무한정 CPU를 할당받지 못하는 상황입니다. 예를 들어 SJF에서 긴 작업은 짧은 작업이 계속 들어오면 실행되지 못하고, Priority 스케줄링에서 낮은 우선순위 프로세스가 무한 대기할 수 있습니다. 해결 방법은 에이징(Aging) 기법으로, 대기 시간이 길어질수록 우선순위를 점진적으로 높여주어 결국 실행될 수 있도록 보장합니다.

---

### Q5. 에이징(Aging) 기법을 설명해주세요.

> 에이징은 오래 대기한 프로세스의 우선순위를 점진적으로 높여주는 기법으로 기아 현상을 방지합니다. 예를 들어 우선순위 스케줄링에서 일정 시간마다 대기 중인 프로세스의 우선순위를 1씩 증가시키면, 낮은 우선순위 프로세스도 결국 높은 우선순위가 되어 실행됩니다. 이를 통해 공정성을 보장하고, 모든 프로세스가 언젠가는 CPU를 할당받을 수 있도록 합니다. 구현은 대기 시간을 추적하고 일정 임계값마다 우선순위를 조정하는 방식으로 이루어집니다.

---

## 비교/구분

### Q6. FCFS, SJF, Round Robin, Priority 스케줄링 알고리즘을 각각 설명하고, 장단점을 비교해주세요.

> FCFS(First-Come, First-Served)는 도착 순서대로 처리하는 비선점 방식으로, 구현이 간단하지만 Convoy Effect가 발생하고 평균 대기 시간이 길어질 수 있습니다. SJF(Shortest Job First)는 실행 시간이 짧은 프로세스를 먼저 처리하여 평균 대기 시간을 최소화하지만, 실행 시간 예측이 어렵고 긴 프로세스의 기아 현상이 발생할 수 있습니다. Round Robin은 각 프로세스에 Time Quantum을 할당하여 순환하는 선점 방식으로, 응답 시간이 빠르고 공정하지만 컨텍스트 스위칭 오버헤드가 있습니다. Priority는 우선순위에 따라 처리하며, 중요한 작업을 먼저 처리할 수 있지만 낮은 우선순위의 기아 현상이 발생할 수 있습니다(에이징으로 해결).

---

### Q7. SJF(Shortest Job First)와 SRTF(Shortest Remaining Time First)의 차이는 무엇인가요?

> SJF는 비선점 방식으로, 실행 시간이 가장 짧은 프로세스를 선택하여 실행하며 한번 실행하면 완료될 때까지 CPU를 점유합니다. 새로운 프로세스가 도착해도 현재 프로세스가 끝날 때까지 기다립니다. SRTF는 SJF의 선점 버전으로, 새로운 프로세스가 도착했을 때 남은 실행 시간이 현재 프로세스보다 짧으면 즉시 선점합니다. SRTF가 평균 대기 시간이 더 짧지만, 컨텍스트 스위칭이 빈번하게 발생하고 구현이 복잡합니다.

---

### Q8. Round Robin 스케줄링에서 Time Quantum이 너무 크거나 작으면 어떤 문제가 발생하나요?

> Time Quantum이 너무 크면 FCFS와 유사하게 동작하여 응답 시간이 길어지고, 짧은 프로세스가 긴 프로세스를 기다리는 Convoy Effect가 발생할 수 있습니다. Time Quantum이 너무 작으면 컨텍스트 스위칭이 매우 빈번하게 발생하여 오버헤드가 증가하고, 실제 작업 처리보다 컨텍스트 스위칭에 더 많은 시간을 소비하게 됩니다. 일반적으로 10~100ms 정도가 적절하며, 컨텍스트 스위칭 시간의 약 10배 정도로 설정하는 것이 권장됩니다.

---

### Q9. CPU 바운드 프로세스와 I/O 바운드 프로세스에 적합한 스케줄링 알고리즘은 무엇인가요?

> CPU 바운드 프로세스는 계산 작업이 많아 CPU를 오래 사용하므로, FCFS나 SJF처럼 한번 실행하면 완료까지 실행하는 알고리즘이 컨텍스트 스위칭을 줄여 효율적입니다. I/O 바운드 프로세스는 I/O 대기가 많아 CPU 사용 시간이 짧으므로, Round Robin이나 Multi-level Feedback Queue처럼 빠른 응답 시간을 제공하는 알고리즘이 적합합니다. 실제 시스템은 두 유형이 혼재하므로 Multi-level Queue를 사용하여 각 유형에 다른 큐와 알고리즘을 적용하기도 합니다.

---

## 심화/실무

### Q10. Convoy Effect(호위 효과)가 무엇이며, 어떤 스케줄링 알고리즘에서 발생하나요?

> Convoy Effect는 실행 시간이 긴 프로세스가 CPU를 점유하고 있을 때, 뒤에 있는 짧은 프로세스들이 오래 기다려야 하는 현상입니다. FCFS 알고리즘에서 주로 발생하며, 예를 들어 실행 시간이 100초인 프로세스가 먼저 도착하고 1초짜리 프로세스 10개가 뒤에 대기하면, 평균 대기 시간이 매우 길어집니다. 이는 CPU 이용률과 처리량을 낮추고, 응답 시간을 크게 증가시킵니다. SJF나 Round Robin 같은 알고리즘을 사용하면 이 문제를 완화할 수 있습니다.

---

### Q11. 멀티레벨 큐(Multi-level Queue)와 멀티레벨 피드백 큐(Multi-level Feedback Queue)의 차이를 설명해주세요.

> 멀티레벨 큐는 프로세스를 우선순위나 유형(포그라운드/백그라운드, CPU바운드/I/O바운드)에 따라 여러 개의 큐로 분류하고, 각 큐는 독립적인 스케줄링 알고리즘을 사용합니다. 프로세스는 할당된 큐에 고정되어 이동할 수 없습니다. 멀티레벨 피드백 큐는 프로세스가 큐 간 이동이 가능하며, CPU 사용 패턴에 따라 동적으로 우선순위가 조정됩니다. 예를 들어 CPU를 오래 사용하면 낮은 우선순위 큐로 이동하고, I/O 후 돌아오면 높은 우선순위 큐로 이동하여 적응적으로 최적화합니다. 현대 운영체제에서 주로 사용됩니다.

---

### Q12. Spring Boot 애플리케이션에서 스레드 풀의 스레드는 어떻게 스케줄링되나요?

> Spring Boot의 Tomcat 스레드 풀은 JVM의 스레드 스케줄링을 따르며, JVM은 운영체제의 네이티브 스레드에 매핑됩니다. 운영체제의 CPU 스케줄러가 실제 스레드 스케줄링을 담당하며, 일반적으로 선점형 우선순위 기반 Round Robin을 사용합니다. 스레드 풀 내부에서는 요청이 큐에 쌓이고, 유휴 스레드가 FIFO 방식으로 작업을 가져와 처리합니다. 개발자는 ThreadPoolTaskExecutor를 설정하여 스레드 풀 크기를 제어할 수 있지만, 개별 스레드의 CPU 스케줄링은 OS가 관리합니다.

---

### Q13. 실시간 시스템(Real-time System)에서는 어떤 스케줄링 알고리즘을 사용하나요?

> 실시간 시스템은 데드라인 내에 작업을 완료해야 하므로, EDF(Earliest Deadline First)나 Rate Monotonic 같은 실시간 스케줄링 알고리즘을 사용합니다. EDF는 데드라인이 가장 가까운 작업을 먼저 실행하는 동적 우선순위 방식으로, 이론적으로 최적이지만 구현이 복잡합니다. Rate Monotonic은 주기가 짧은 작업에 높은 우선순위를 부여하는 정적 우선순위 방식으로, 구현이 간단하지만 CPU 이용률이 약 69%로 제한됩니다. 하드 실시간 시스템(항공, 의료)은 데드라인 미스가 치명적이므로 더 엄격한 보장이 필요합니다.

---

## 꼬리질문

### Q14. 우선순위 스케줄링에서 우선순위를 결정하는 기준은 무엇인가요?

> 우선순위는 내부적(Internal)과 외부적(External) 기준으로 나뉩니다. 내부적 기준은 실행 시간(짧을수록 높음), 메모리 요구량(적을수록 높음), I/O 대 CPU 비율(I/O 바운드가 높음) 등 시스템이 측정 가능한 요소입니다. 외부적 기준은 프로세스의 중요도, 사용자 계층(관리자/일반 사용자), 비용(더 많이 지불한 사용자), 정책 등 시스템 외부에서 결정되는 요소입니다. 실제로는 두 기준을 조합하여 사용하며, 에이징으로 대기 시간도 우선순위에 반영합니다.

---

### Q15. 컨텍스트 스위칭을 최소화하는 스케줄링 방법은 무엇인가요?

> 비선점 스케줄링(FCFS, SJF)을 사용하면 프로세스가 자발적으로 CPU를 반납할 때만 스위칭이 발생하여 컨텍스트 스위칭이 최소화됩니다. Round Robin의 Time Quantum을 크게 설정하면 스위칭 빈도가 줄어들지만 응답 시간이 길어집니다. 또한 프로세스 친화도(Processor Affinity)를 사용하여 같은 프로세스를 같은 CPU 코어에서 실행하면 캐시 히트율이 높아져 효율적입니다. 하지만 컨텍스트 스위칭 최소화만을 목표로 하면 응답 시간과 공정성이 저하되므로, 시스템 특성에 맞는 균형이 필요합니다.
