# 2. CPU 스케줄링

---

## CPU 스케줄링이란?

Ready 상태의 프로세스 중 **누구에게 CPU를 줄 것인가** 결정하는 것.

```
Ready Queue: [P1, P2, P3, P4]
                    │
              CPU 스케줄러가 선택
                    │
                    ↓
               [P2] → CPU에서 실행
```

프로세스는 여러 개인데 CPU(코어)는 한정적이니까, 순서를 정해야 한다.

---

## 선점 vs 비선점

### 비선점 (Non-preemptive)

```
프로세스가 CPU를 잡으면 끝날 때까지 양보 안 함
P1 실행 ─────────────────→ 완료 → P2 실행 시작
         P2는 기다림...
```

- 프로세스가 스스로 CPU를 놓을 때까지 기다림
- 컨텍스트 스위칭 적음
- 응답 시간이 길어질 수 있음

### 선점 (Preemptive)

```
P1 실행 ────── 타이머 인터럽트! ──→ P2 실행
              OS가 P1에서 CPU를 빼앗음
```

- OS가 강제로 CPU를 빼앗을 수 있음
- 응답 시간이 짧음 (공평)
- 컨텍스트 스위칭이 자주 발생
- **현대 OS는 대부분 선점형**

---

## 스케줄링 알고리즘

### FCFS (First Come, First Served) - 비선점

먼저 온 순서대로 처리. 줄 서기와 같다.

```
도착 순서: P1(24ms) → P2(3ms) → P3(3ms)

실행: P1 ────────────────────── P2 ─── P3 ───
      0                       24    27    30

평균 대기 시간: (0 + 24 + 27) / 3 = 17ms
```

- 장점: 구현 간단
- 단점: **Convoy Effect** - 긴 프로세스 뒤에 짧은 프로세스가 오래 기다림

### SJF (Shortest Job First) - 비선점

실행 시간이 짧은 것부터 처리.

```
P1(24ms), P2(3ms), P3(3ms)

실행: P2 ─── P3 ─── P1 ──────────────────────
      0     3      6                        30

평균 대기 시간: (6 + 0 + 3) / 3 = 3ms (FCFS보다 훨씬 좋음!)
```

- 장점: 평균 대기 시간 최소
- 단점: 실행 시간을 미리 알 수 없음, **기아(Starvation)** - 긴 프로세스가 계속 밀림

### Round Robin (RR) - 선점

각 프로세스에 동일한 시간(Time Quantum)을 주고 돌아가며 실행.

```
Time Quantum = 4ms
P1(24ms), P2(3ms), P3(3ms)

실행: P1 ──── P2 ─── P3 ─── P1 ──── P1 ──── P1 ──── P1 ──── P1 ────
      0      4      7     10     14     18     22     26     30

평균 대기 시간: ((30-24) + 4 + 7) / 3 = 5.67ms
```

- 장점: **공평함**, 응답 시간이 짧음
- 단점: Time Quantum이 너무 크면 FCFS와 같고, 너무 작으면 컨텍스트 스위칭 오버헤드
- **현대 OS의 기본 스케줄링 방식**

### Priority Scheduling - 선점/비선점

우선순위가 높은 프로세스부터 실행.

- 단점: **기아(Starvation)** - 낮은 우선순위가 영원히 실행 안 될 수 있음
- 해결: **에이징(Aging)** - 오래 기다린 프로세스의 우선순위를 점진적으로 올림

### 멀티레벨 큐 (Multilevel Queue)

```
[높은 우선순위] 시스템 프로세스 큐   → Round Robin
[중간 우선순위] 대화형 프로세스 큐   → Round Robin
[낮은 우선순위] 배치 프로세스 큐     → FCFS
```

- 프로세스 유형별로 다른 큐와 다른 알고리즘 적용
- 실제 OS에서 사용하는 방식

---

## 스케줄링 성능 지표

| 지표 | 의미 | 좋은 방향 |
|------|------|----------|
| **CPU 이용률** | CPU가 일하는 비율 | 높을수록 좋음 |
| **처리량(Throughput)** | 단위 시간당 완료된 프로세스 수 | 높을수록 좋음 |
| **대기 시간(Waiting Time)** | Ready Queue에서 기다린 시간 | 짧을수록 좋음 |
| **응답 시간(Response Time)** | 요청 후 첫 응답까지 시간 | 짧을수록 좋음 |
| **반환 시간(Turnaround Time)** | 제출 후 완료까지 총 시간 | 짧을수록 좋음 |

---

## Spring Boot와의 연결

```
Spring Boot 서버에 동시에 100개 요청이 들어오면:

1. Tomcat 스레드 풀에서 스레드 할당 (최대 200개)
2. 각 스레드가 OS의 스케줄링 대상이 됨
3. OS가 Round Robin 등의 알고리즘으로 CPU 시간을 분배
4. 스레드가 DB I/O를 기다리면 → Blocked 상태 → 다른 스레드에 CPU 할당
5. I/O 완료 → Ready → 다시 스케줄링 받아 실행
```

> 면접에서 "스레드 풀이 왜 200개가 적절한가?"라는 질문이 올 수 있다.
> CPU 코어 수와 I/O 비율에 따라 최적 스레드 수가 달라진다.
> I/O가 많은 서비스(DB 조회 위주)는 스레드를 더 많이 가져도 된다.

---

## 면접 핵심 정리

**Q: 선점형과 비선점형 스케줄링의 차이는?**
> 비선점형은 프로세스가 CPU를 자발적으로 놓을 때까지 기다리고,
> 선점형은 OS가 강제로 CPU를 빼앗을 수 있습니다.
> 현대 OS는 선점형을 사용하여 응답 시간을 보장합니다.

**Q: Round Robin의 장단점은?**
> 모든 프로세스에 동일한 시간을 주므로 공평하고 응답 시간이 짧습니다.
> Time Quantum이 너무 크면 FCFS와 같아지고, 너무 작으면
> 컨텍스트 스위칭 오버헤드가 커져 적절한 크기를 설정해야 합니다.

**Q: 기아(Starvation)란 무엇이고 어떻게 해결하나요?**
> 우선순위가 낮은 프로세스가 높은 우선순위에 밀려 무한히 실행되지 못하는 현상입니다.
> 에이징(Aging)으로 해결합니다. 오래 기다린 프로세스의 우선순위를 점진적으로 올려서
> 결국 실행될 수 있도록 합니다.
