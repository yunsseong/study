# 동기화와 데드락 면접 질문 + 답변

---

## 기본 개념

### Q1. Race Condition(경쟁 상태)이 무엇이며, 왜 발생하나요?

> Race Condition은 여러 프로세스나 스레드가 공유 자원에 동시에 접근할 때, 실행 순서에 따라 결과가 달라지는 상황입니다. 예를 들어 두 스레드가 count++ 연산을 수행하면, 읽기-증가-쓰기 과정에서 컨텍스트 스위칭이 발생하여 최종 값이 예상과 다를 수 있습니다. 멀티스레드 환경에서 Heap 영역의 공유 자원(전역 변수, 인스턴스 변수)에 대한 동시 접근으로 발생하며, 동기화(Synchronization) 메커니즘 없이는 데이터 무결성이 깨집니다.

---

### Q2. 임계 영역(Critical Section)이 무엇이고, 임계 영역 문제를 해결하기 위한 3가지 조건을 설명해주세요.

> 임계 영역은 공유 자원에 접근하는 코드 영역으로, 한 번에 하나의 프로세스만 실행되어야 합니다. 해결 조건은 첫째, 상호 배제(Mutual Exclusion)로 한 프로세스가 임계 영역을 실행 중이면 다른 프로세스는 진입할 수 없습니다. 둘째, 진행(Progress)으로 임계 영역이 비어있고 진입하려는 프로세스가 있으면 합리적인 시간 내에 진입해야 합니다. 셋째, 한정 대기(Bounded Waiting)로 프로세스가 임계 영역 진입을 무한정 기다리지 않도록 보장해야 합니다.

---

### Q3. Mutex와 Semaphore의 차이점을 설명해주세요.

> Mutex(Mutual Exclusion)는 상호 배제를 위한 이진 락으로, 임계 영역에 하나의 스레드만 접근할 수 있도록 보장합니다. 락을 획득한 스레드만 해제할 수 있으며(소유권 개념), 주로 공유 자원 보호에 사용됩니다. Semaphore는 정수 값으로 동시 접근 가능한 스레드 수를 제어하며, 카운팅 세마포어(N개 허용)와 이진 세마포어(1개 허용)가 있습니다. 소유권 개념이 없어 한 스레드가 획득하고 다른 스레드가 해제할 수 있으며, 주로 순서 제어나 리소스 풀 관리에 사용됩니다.

---

### Q4. Monitor가 무엇이며, Mutex/Semaphore와 어떻게 다른가요?

> Monitor는 공유 자원과 이를 접근하는 메서드를 하나로 묶은 고수준 동기화 구조체로, 한 번에 하나의 스레드만 모니터 내부 메서드를 실행할 수 있습니다. Mutex/Semaphore는 저수준 동기화 도구로 개발자가 명시적으로 획득/해제를 관리해야 하지만, Monitor는 컴파일러나 언어 차원에서 자동으로 동기화를 처리합니다. Java의 synchronized는 모니터를 구현하며, 조건 변수(wait/notify)를 통해 스레드 간 협력도 지원합니다. Mutex보다 사용이 쉽고 안전하지만 성능은 약간 낮을 수 있습니다.

---

### Q5. 데드락(Deadlock)의 정의와 발생 조건 4가지를 설명해주세요.

> 데드락은 둘 이상의 프로세스가 서로가 가진 자원을 기다리며 무한정 대기하는 상태입니다. 발생 조건은 첫째, 상호 배제(Mutual Exclusion)로 자원은 한 번에 하나의 프로세스만 사용 가능합니다. 둘째, 점유와 대기(Hold and Wait)로 자원을 보유한 채 다른 자원을 기다립니다. 셋째, 비선점(No Preemption)으로 자원을 강제로 빼앗을 수 없습니다. 넷째, 순환 대기(Circular Wait)로 프로세스들이 순환 형태로 자원을 기다립니다. 네 가지 조건이 모두 성립해야 데드락이 발생합니다.

---

## 비교/구분

### Q6. Mutex, Binary Semaphore, Counting Semaphore를 비교 설명해주세요.

> Mutex는 이진 락으로 소유권이 있어 락을 획득한 스레드만 해제할 수 있으며, 주로 임계 영역 보호에 사용됩니다. 재진입(Reentrant) 가능한 Mutex도 있습니다. Binary Semaphore는 0 또는 1의 값을 가지며 소유권 개념이 없어 한 스레드가 P(wait), 다른 스레드가 V(signal)를 호출할 수 있어 시그널링에 유용합니다. Counting Semaphore는 N개의 자원을 관리하며, 리소스 풀(DB 커넥션 풀, 스레드 풀)에서 동시 접근을 제한하는 데 사용됩니다. Mutex는 1:1 소유, Semaphore는 N:M 제어로 구분됩니다.

---

### Q7. Spinlock과 일반 Lock(Sleep Lock)의 차이와 각각의 사용 시나리오를 설명해주세요.

> Spinlock은 락을 획득할 때까지 루프를 돌며 계속 확인(바쁜 대기)하여 CPU를 소모하지만 컨텍스트 스위칭이 없어 빠릅니다. 임계 영역이 매우 짧을 때(수 마이크로초) 유용하며, 커널 내부나 인터럽트 핸들러에서 사용됩니다. Sleep Lock은 락을 획득할 수 없으면 스레드를 대기 상태로 전환하여 CPU를 양보하고, 락이 해제되면 깨워집니다. 컨텍스트 스위칭 비용이 있지만 CPU 낭비가 없어 임계 영역이 긴 경우 적합합니다. 일반적인 애플리케이션에서는 Sleep Lock을 사용합니다.

---

### Q8. 데드락 처리 방법 4가지(예방, 회피, 탐지, 무시)를 설명하고, 각각의 장단점을 비교해주세요.

> 예방(Prevention)은 데드락 발생 조건 4가지 중 하나를 원천 차단합니다. 예를 들어 자원을 한 번에 모두 요청하여 점유와 대기를 제거하거나, 자원에 순서를 부여하여 순환 대기를 방지합니다. 확실하지만 자원 활용률이 낮습니다. 회피(Avoidance)는 은행원 알고리즘처럼 안전 상태를 유지하며 자원을 할당하여 데드락 가능성을 피합니다. 안전하지만 사전 정보가 필요하고 오버헤드가 큽니다. 탐지(Detection)는 데드락 발생을 허용하고 주기적으로 탐지하여 회복합니다. 자원 활용률이 높지만 회복 비용이 큽니다. 무시(Ignorance)는 데드락을 처리하지 않고, 발생 시 재부팅합니다. Unix/Windows가 사용하며, 발생 빈도가 낮을 때 합리적입니다.

---

### Q9. Java의 synchronized 키워드와 ReentrantLock의 차이점은 무엇인가요?

> synchronized는 간단하고 자동으로 락을 획득/해제하며(블록 종료 시 자동 해제), 모니터 기반으로 동작합니다. 하지만 타임아웃 설정이 불가능하고, 공정성(fairness) 제어가 어렵습니다. ReentrantLock은 명시적으로 lock()/unlock()을 호출하며, tryLock(timeout)으로 타임아웃 설정, lockInterruptibly()로 인터럽트 가능, 공정성 모드(fair=true)로 대기 순서 보장이 가능합니다. 또한 Condition을 여러 개 사용할 수 있어 세밀한 스레드 제어가 가능합니다. synchronized는 간단한 경우, ReentrantLock은 복잡한 동기화가 필요한 경우 사용합니다.

---

## 심화/실무

### Q10. 은행원 알고리즘(Banker's Algorithm)이 무엇이며, 어떻게 데드락을 회피하나요?

> 은행원 알고리즘은 자원 할당 요청 시 시스템이 안전 상태를 유지하는지 확인하여 데드락을 회피하는 알고리즘입니다. 각 프로세스의 최대 자원 요구량을 사전에 알고, 현재 할당된 자원과 사용 가능한 자원을 추적합니다. 요청이 들어오면 가상으로 할당했을 때 안전 순서(모든 프로세스가 완료 가능한 순서)가 존재하는지 확인하고, 존재하면 할당하고 아니면 대기시킵니다. 안전 상태는 시스템이 데드락 없이 모든 프로세스를 완료할 수 있는 상태입니다. 실무에서는 사전 정보 획득이 어렵고 오버헤드가 커서 잘 사용되지 않습니다.

---

### Q11. 데이터베이스에서 데드락이 발생하는 상황과 해결 방법을 설명해주세요.

> 두 트랜잭션이 서로 다른 순서로 행을 잠그면 데드락이 발생합니다. 예를 들어 트랜잭션 A가 행1을 잠그고 행2를 요청하고, 트랜잭션 B가 행2를 잠그고 행1을 요청하면 순환 대기가 발생합니다. 해결 방법은 첫째, 일관된 순서로 자원을 잠그는 것입니다(예: ID 순서). 둘째, 트랜잭션을 짧게 유지하여 락 보유 시간을 줄입니다. 셋째, 적절한 인덱스를 사용하여 락 범위를 최소화합니다. 넷째, DB의 자동 데드락 탐지 및 롤백 기능을 활용합니다. 다섯째, 낙관적 락(Optimistic Lock)이나 비관적 락(Pessimistic Lock)을 상황에 맞게 사용합니다.

---

### Q12. Spring Boot 애플리케이션에서 동시성 문제가 발생할 수 있는 상황과 해결 방법을 설명해주세요.

> 싱글톤 빈의 인스턴스 변수를 여러 스레드가 동시에 수정하면 Race Condition이 발생합니다. 예를 들어 @Service의 count 필드를 증가시키면 동시 요청 시 값이 손실됩니다. 해결 방법은 첫째, 인스턴스 변수 대신 지역 변수를 사용하여 스레드마다 독립적인 메모리를 갖도록 합니다. 둘째, @Transactional로 트랜잭션 격리 수준을 조정합니다. 셋째, synchronized나 ReentrantLock으로 임계 영역을 보호합니다. 넷째, AtomicInteger 같은 동시성 컬렉션을 사용합니다. 다섯째, 분산 환경에서는 Redis나 DB의 분산 락을 사용합니다. 여섯째, @Scope("prototype")으로 빈을 요청마다 새로 생성합니다.

---

### Q13. Reader-Writer Problem과 그 해결 방법을 설명해주세요.

> Reader-Writer Problem은 여러 스레드가 공유 자원을 읽고 쓸 때, 읽기는 동시에 가능하지만 쓰기는 배타적으로 수행되어야 하는 문제입니다. 단순 Mutex를 사용하면 읽기도 직렬화되어 비효율적입니다. 해결 방법은 Reader-Writer Lock을 사용하는 것으로, 읽기 락은 여러 스레드가 동시에 획득 가능하고, 쓰기 락은 배타적입니다. Java에서는 ReentrantReadWriteLock을 제공합니다. 읽기 우선 정책은 쓰기 기아가 발생할 수 있고, 쓰기 우선 정책은 읽기 대기 시간이 늘어날 수 있어 공정 정책을 사용하기도 합니다.

---

## 꼬리질문

### Q14. 데드락과 기아(Starvation), 라이브락(Livelock)의 차이는 무엇인가요?

> 데드락은 여러 프로세스가 서로의 자원을 기다리며 무한정 대기하는 상태로, 진행이 완전히 멈춥니다. 기아는 특정 프로세스가 우선순위가 낮거나 스케줄링 알고리즘 때문에 무한정 자원을 할당받지 못하는 상태로, 다른 프로세스는 진행됩니다. 라이브락은 프로세스들이 데드락을 피하려고 계속 상태를 변경하지만 실제로는 진행하지 못하는 상태입니다. 예를 들어 두 사람이 좁은 복도에서 서로 비켜주려고 같은 방향으로 움직여 계속 막히는 상황입니다. 라이브락은 CPU를 소모하지만 진행이 없습니다.

---

### Q15. Java에서 synchronized 블록과 synchronized 메서드의 차이는 무엇인가요?

> synchronized 메서드는 메서드 전체를 동기화하며, 인스턴스 메서드는 this 객체를 락으로 사용하고, static 메서드는 클래스 객체(Class 객체)를 락으로 사용합니다. synchronized 블록은 특정 코드 영역만 동기화하며, 락 객체를 명시적으로 지정할 수 있습니다. 블록을 사용하면 임계 영역을 최소화하여 성능을 향상시킬 수 있고, 여러 개의 락을 사용하여 세밀한 동기화가 가능합니다. 예를 들어 synchronized(lockA)와 synchronized(lockB)로 다른 자원을 독립적으로 보호할 수 있습니다.
