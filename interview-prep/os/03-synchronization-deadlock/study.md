# 3. 동기화와 데드락

---

## 왜 동기화가 필요한가?

멀티 스레드에서 **공유 자원**에 동시에 접근하면 문제가 생긴다.

```java
// 잔액: 10,000원
// 스레드 A: 출금 7,000원
// 스레드 B: 출금 5,000원

스레드 A: 잔액 읽기 → 10,000원
스레드 B: 잔액 읽기 → 10,000원       ← A가 아직 저장 안 했는데 B도 읽음!
스레드 A: 10,000 - 7,000 = 3,000 저장
스레드 B: 10,000 - 5,000 = 5,000 저장 ← 3,000을 덮어씀!

결과: 잔액 5,000원 (총 12,000원 출금됐는데 5,000원 남음)
```

이런 문제를 **경쟁 상태(Race Condition)**라고 한다.

> **Spring Boot 포트폴리오에서 "선착순 쿠폰 시스템"의 핵심 문제가 바로 이것이다.**
> 100개 쿠폰에 1000명이 동시 요청 → Race Condition → 137개 발급

---

## 핵심 용어

| 용어 | 의미 |
|------|------|
| **경쟁 상태 (Race Condition)** | 여러 스레드가 공유 자원에 동시 접근하여 결과가 실행 순서에 따라 달라지는 현상 |
| **임계 영역 (Critical Section)** | 공유 자원에 접근하는 코드 영역. 한 번에 하나의 스레드만 진입해야 한다 |
| **상호 배제 (Mutual Exclusion)** | 한 스레드가 임계 영역에 있으면 다른 스레드는 진입할 수 없다 |

```java
// 임계 영역 예시
public void withdraw(int amount) {
    // ─── 임계 영역 시작 ───
    if (balance >= amount) {       // 읽기
        balance -= amount;         // 쓰기
    }
    // ─── 임계 영역 끝 ───
}
```

---

## 동기화 도구

### 1. Mutex (뮤텍스)

**열쇠가 1개인 화장실.** 한 사람이 들어가면 잠기고, 나와야 다음 사람이 들어간다.

```
스레드 A: lock 획득 → 임계 영역 실행 → unlock
스레드 B: lock 시도 → 대기... → A가 unlock → lock 획득 → 실행
```

- 한 번에 **1개 스레드만** 진입
- 소유권이 있음 (lock한 스레드만 unlock 가능)

### 2. Semaphore (세마포어)

**N개 좌석이 있는 식당.** N명까지 동시 입장 가능.

```
세마포어 값 = 3 (동시 3개 스레드 가능)

스레드 A: wait() → 값 2 → 진입
스레드 B: wait() → 값 1 → 진입
스레드 C: wait() → 값 0 → 진입
스레드 D: wait() → 값 0이라 대기...
스레드 A: signal() → 값 1 → 스레드 D 진입 가능
```

| 비교 | Mutex | Semaphore |
|------|-------|-----------|
| 동시 접근 | 1개만 | N개 가능 |
| 소유권 | 있음 (lock한 놈이 unlock) | 없음 (아무나 signal 가능) |
| 용도 | 상호 배제 | 자원 수 제한 |

> **Semaphore(1) = Mutex와 유사** (이진 세마포어)

### 3. Monitor

Mutex + 조건 변수를 합친 고수준 동기화 도구.
**Java의 `synchronized`가 모니터 기반이다.**

```java
// Java에서 모니터 사용
public synchronized void withdraw(int amount) {
    if (balance >= amount) {
        balance -= amount;
    }
}
// → 한 번에 하나의 스레드만 이 메서드 실행 가능
```

---

## 동기화 문제

### Producer-Consumer 문제

생산자가 데이터를 버퍼에 넣고, 소비자가 꺼내 쓰는 상황.

```
[생산자] → [버퍼 ■■■□□] → [소비자]

문제:
- 버퍼가 꽉 찼는데 생산자가 넣으려 함 → 대기해야 함
- 버퍼가 비었는데 소비자가 꺼내려 함 → 대기해야 함
- 동시에 버퍼에 접근하면 → Race Condition
```

> **실무 연결**: Kafka의 Producer-Consumer가 바로 이 패턴이다.

---

## 데드락 (Deadlock)

### 데드락이란?

두 개 이상의 프로세스가 서로 상대방이 가진 자원을 기다리며 **영원히 진행하지 못하는 상태**.

```
스레드 A: 자원 1 보유, 자원 2 요청 → 대기
스레드 B: 자원 2 보유, 자원 1 요청 → 대기
→ 서로 기다리기만 하고 아무도 진행 못함 = 데드락
```

현실 비유:
```
좁은 골목에서 차 두 대가 마주침
A: "너 먼저 비켜"
B: "아니 너 먼저 비켜"
→ 둘 다 안 비키면 영원히 못 지나감
```

### 데드락 발생 조건 4가지 (모두 충족해야 발생)

| 조건 | 의미 | 예시 |
|------|------|------|
| **상호 배제** | 자원은 한 번에 하나만 사용 | 프린터 1대를 2명이 동시에 못 씀 |
| **점유 대기** | 자원을 보유하면서 다른 자원을 기다림 | A가 프린터 잡고 스캐너 기다림 |
| **비선점** | 다른 프로세스의 자원을 빼앗을 수 없음 | A의 프린터를 강제로 빼앗을 수 없음 |
| **순환 대기** | 자원 요청이 원형으로 대기 | A→B→C→A 순환 |

> **면접 단골**: "데드락 발생 조건 4가지를 말해주세요" → 반드시 외워야 함

### 데드락 처리 방법

**1. 예방 (Prevention)**: 4가지 조건 중 하나를 원천 차단

```
상호 배제 제거: 어려움 (자원 특성상)
점유 대기 제거: 필요한 자원을 모두 한꺼번에 요청
비선점 제거: 자원을 빼앗을 수 있게 허용
순환 대기 제거: 자원에 번호를 매기고 순서대로만 요청
```

**2. 회피 (Avoidance)**: 데드락이 발생할 수 있는 상태를 피함

```
은행원 알고리즘 (Banker's Algorithm):
- 자원을 줬을 때 안전한 상태인지 미리 계산
- 안전하면 할당, 불안전하면 거부
```

**3. 탐지 + 회복 (Detection + Recovery)**

```
- 주기적으로 데드락 발생 여부 검사
- 발견되면 프로세스를 하나 강제 종료하여 자원 회수
```

**4. 무시 (Ignore)**

```
- 데드락이 드물게 발생하면 그냥 무시
- 발생하면 재부팅
- 대부분의 OS가 이 방식 (처리 비용이 더 큼)
```

---

## Spring Boot / 실무에서의 데드락

### DB 데드락

```sql
-- 트랜잭션 A
UPDATE accounts SET balance = balance - 100 WHERE id = 1;  -- row 1 락
UPDATE accounts SET balance = balance + 100 WHERE id = 2;  -- row 2 대기

-- 트랜잭션 B (동시에)
UPDATE accounts SET balance = balance - 50 WHERE id = 2;   -- row 2 락
UPDATE accounts SET balance = balance + 50 WHERE id = 1;   -- row 1 대기

→ A는 row 2를, B는 row 1을 기다리며 데드락!
```

**해결법**: 항상 같은 순서로 자원을 접근 (id 1 → id 2 순서로 통일)

### Java synchronized 데드락

```java
// 데드락 발생 코드
synchronized(lockA) {
    synchronized(lockB) { ... }  // 스레드 1
}
synchronized(lockB) {
    synchronized(lockA) { ... }  // 스레드 2
}

// 해결: 항상 같은 순서로 lock
synchronized(lockA) {
    synchronized(lockB) { ... }  // 스레드 1, 2 모두 A→B 순서
}
```

---

## 면접 핵심 정리

**Q: Race Condition이란 무엇인가요?**
> 여러 스레드가 공유 자원에 동시에 접근하여, 실행 순서에 따라 결과가 달라지는 현상입니다.
> 임계 영역에 대한 상호 배제를 보장하여 해결합니다.
> Java에서는 synchronized, Lock 등으로 구현합니다.

**Q: Mutex와 Semaphore의 차이는?**
> Mutex는 한 번에 1개 스레드만 접근 가능하고 소유권이 있어 lock한 스레드만 unlock 가능합니다.
> Semaphore는 N개 스레드가 동시 접근 가능하고 소유권이 없습니다.
> Mutex는 상호 배제, Semaphore는 동시 접근 수 제한에 사용합니다.

**Q: 데드락 발생 조건 4가지를 말해주세요**
> 상호 배제, 점유 대기, 비선점, 순환 대기 4가지가 모두 충족되면 데드락이 발생합니다.
> 해결하려면 이 중 하나를 깨면 됩니다.
> 실무에서는 자원 접근 순서를 통일하여 순환 대기를 방지하는 방법을 많이 사용합니다.

**Q: DB 데드락은 어떻게 해결하나요?**
> 항상 같은 순서로 row에 접근하도록 통일합니다.
> 예를 들어 id가 작은 것부터 접근하면 순환 대기가 발생하지 않습니다.
> MySQL은 데드락을 감지하면 한쪽 트랜잭션을 자동으로 롤백합니다.
