# React 기초 면접 질문 + 답변

## 기본 개념 (1~5)

**Q1.** JSX란 무엇이며, 왜 사용하나요?

> JSX(JavaScript XML)는 JavaScript를 확장한 문법으로, HTML과 유사한 구조로 UI를 표현할 수 있게 해줍니다. React.createElement() 호출을 간결하게 작성할 수 있는 syntactic sugar입니다. Babel과 같은 트랜스파일러를 통해 일반 JavaScript로 변환되며, 컴포넌트의 구조를 시각적으로 파악하기 쉽고 HTML과 JavaScript 로직을 한 곳에서 작성할 수 있어 생산성이 향상됩니다. 타입 안정성을 제공하며, XSS 공격을 방지하기 위해 자동으로 이스케이프 처리됩니다.

**Q2.** React 컴포넌트란 무엇이며, 어떤 종류가 있나요?

> React 컴포넌트는 UI를 독립적이고 재사용 가능한 조각으로 나눈 것으로, props를 입력받아 React 엘리먼트를 반환하는 함수나 클래스입니다. 크게 함수형 컴포넌트와 클래스 컴포넌트로 나뉩니다. 함수형 컴포넌트는 단순히 함수로 정의되며 Hooks를 통해 상태와 생명주기를 관리합니다. 클래스 컴포넌트는 React.Component를 상속받아 정의하며 생명주기 메서드를 사용합니다. 현재는 간결성과 Hooks의 강력함 때문에 함수형 컴포넌트가 권장됩니다.

**Q3.** Virtual DOM이란 무엇이고, React는 어떻게 이를 활용하나요?

> Virtual DOM은 실제 DOM의 가벼운 JavaScript 객체 표현입니다. React는 상태가 변경될 때 새로운 Virtual DOM 트리를 생성하고, 이전 트리와 비교(Diffing)하여 실제로 변경된 부분만 찾아냅니다. 이 과정을 Reconciliation이라 하며, 변경된 부분만 실제 DOM에 반영(Batch Update)합니다. 이를 통해 불필요한 DOM 조작을 최소화하여 성능을 최적화합니다. 실제 DOM 조작은 비용이 크기 때문에, Virtual DOM을 통한 최적화는 React의 핵심 성능 전략입니다.

**Q4.** Props와 State의 차이점은 무엇인가요?

> Props는 부모 컴포넌트로부터 전달받는 읽기 전용 데이터로, 컴포넌트 외부에서 관리되며 불변(immutable)입니다. 마치 함수의 매개변수처럼 동작합니다. State는 컴포넌트 내부에서 관리되는 가변(mutable) 데이터로, setState나 useState를 통해 변경할 수 있습니다. State가 변경되면 컴포넌트가 리렌더링됩니다. Props는 컴포넌트 간 데이터 전달에 사용되고, State는 컴포넌트의 동적인 데이터를 관리하는 데 사용됩니다. 일반적으로 상위 컴포넌트의 State가 하위 컴포넌트의 Props로 전달됩니다.

**Q5.** React에서 이벤트를 처리하는 방법과 일반 DOM 이벤트와의 차이점은?

> React는 SyntheticEvent라는 크로스 브라우저 래퍼를 사용하여 이벤트를 처리합니다. camelCase 네이밍을 사용하고(onClick, onChange), 문자열 대신 함수를 전달하며, preventDefault를 명시적으로 호출해야 합니다. SyntheticEvent는 모든 브라우저에서 동일하게 동작하며, 이벤트 위임(Event Delegation)을 통해 성능을 최적화합니다. React 17 이전에는 모든 이벤트가 document에 위임되었고, 17 이후부터는 root DOM 컨테이너에 위임됩니다. 이벤트 풀링으로 객체 재사용을 통해 메모리를 절약합니다.

## 비교/구분 (6~9)

**Q6.** 함수형 컴포넌트와 클래스 컴포넌트의 차이점은 무엇인가요?

> 함수형 컴포넌트는 단순히 함수로 정의되며, Hooks를 통해 상태와 생명주기를 관리합니다. 코드가 간결하고 this 바인딩이 필요 없으며, 테스트가 쉽습니다. 클래스 컴포넌트는 ES6 클래스로 정의되며, 생명주기 메서드(componentDidMount 등)를 직접 사용합니다. this 키워드를 사용해야 하며 코드가 복잡해질 수 있습니다. React 16.8 이후 Hooks 도입으로 함수형 컴포넌트에서도 모든 기능을 사용할 수 있게 되어, 현재는 함수형 컴포넌트가 공식 권장 방식입니다. 클래스 컴포넌트는 레거시 코드 유지보수 목적으로만 사용됩니다.

**Q7.** 제어 컴포넌트(Controlled Component)와 비제어 컴포넌트(Uncontrolled Component)의 차이는?

> 제어 컴포넌트는 React State에 의해 값이 제어되는 입력 폼 엘리먼트입니다. value를 state로 관리하고 onChange 이벤트로 업데이트하여, React가 단일 진실 공급원(Single Source of Truth)이 됩니다. 실시간 유효성 검사, 조건부 비활성화, 입력 포맷팅 등이 쉽습니다. 비제어 컴포넌트는 DOM 자체가 데이터를 관리하며, ref를 통해 필요할 때 값을 가져옵니다. 간단한 폼이나 파일 입력에 적합하며, 코드가 간결하지만 React의 제어를 벗어나므로 일반적으로 제어 컴포넌트가 권장됩니다.

**Q8.** React의 선언적(Declarative) 프로그래밍과 명령적(Imperative) 프로그래밍의 차이는?

> 선언적 프로그래밍은 "무엇을" 표현할지 정의하는 방식으로, React는 상태에 따라 UI가 어떻게 보여야 하는지 선언합니다. 상태가 변경되면 React가 자동으로 DOM을 업데이트합니다. 코드가 예측 가능하고 디버깅이 쉬우며, 복잡한 UI도 관리하기 쉽습니다. 명령적 프로그래밍은 "어떻게" 할지 단계별로 명령하는 방식으로, 직접 DOM을 조작합니다(getElementById, appendChild 등). React의 선언적 접근은 UI와 상태의 동기화를 자동화하여 개발자가 비즈니스 로직에 집중할 수 있게 합니다.

**Q9.** Props Drilling 문제란 무엇이며, 어떻게 해결할 수 있나요?

> Props Drilling은 props를 여러 계층의 컴포넌트를 거쳐 전달해야 하는 문제입니다. 중간 컴포넌트들은 해당 props를 사용하지 않지만 단순히 전달만 하게 되어 코드가 복잡해지고 유지보수가 어려워집니다. 해결 방법으로는 Context API를 사용하여 전역 상태를 공유하거나, 상태 관리 라이브러리(Redux, Zustand, Recoil 등)를 사용할 수 있습니다. Component Composition(컴포넌트 합성)을 통해 구조를 재설계하거나, children props를 활용하는 방법도 있습니다. 프로젝트 규모와 복잡도에 따라 적절한 해결책을 선택해야 합니다.

## 심화/실무 (10~12)

**Q10.** 리스트를 렌더링할 때 key prop이 왜 필요하며, 어떤 값을 사용해야 하나요?

> key는 React가 어떤 항목이 변경, 추가, 삭제되었는지 식별하는 데 사용됩니다. Virtual DOM의 Diffing 알고리즘에서 리스트 아이템의 변경을 효율적으로 감지하기 위해 필수입니다. key는 형제 요소 사이에서 고유해야 하며, 안정적이고 예측 가능하며 고유한 값이어야 합니다. 가장 좋은 것은 데이터의 고유 ID(user.id)를 사용하는 것이고, 배열 인덱스는 항목의 순서가 변경될 수 있거나 추가/삭제가 발생하는 경우 성능 문제와 버그를 유발할 수 있어 권장되지 않습니다. Math.random()이나 uuid는 매 렌더링마다 새로운 key를 생성하여 성능을 저하시키므로 사용하면 안 됩니다.

**Q11.** React 컴포넌트의 리렌더링은 언제 발생하나요?

> 컴포넌트는 다음 세 가지 경우에 리렌더링됩니다. 1) State가 변경될 때 - setState나 useState의 setter 함수 호출 시, 2) Props가 변경될 때 - 부모 컴포넌트로부터 받은 props 값이 달라질 때, 3) 부모 컴포넌트가 리렌더링될 때 - 기본적으로 자식 컴포넌트도 함께 리렌더링됩니다. Context 값이 변경되어도 해당 Context를 구독하는 모든 컴포넌트가 리렌더링됩니다. 강제로 리렌더링을 유발하는 forceUpdate()도 있지만 권장되지 않습니다. React.memo, useMemo, useCallback을 사용하여 불필요한 리렌더링을 방지할 수 있습니다.

**Q12.** React의 단방향 데이터 흐름(One-way Data Flow)이란 무엇이며, 왜 중요한가요?

> 단방향 데이터 흐름은 데이터가 부모에서 자식으로만 props를 통해 전달되는 React의 핵심 원칙입니다. 자식 컴포넌트는 받은 props를 직접 수정할 수 없고, 부모로부터 전달받은 콜백 함수를 통해서만 상위 상태를 변경할 수 있습니다. 이를 통해 데이터의 흐름이 명확하고 예측 가능해지며, 디버깅이 쉬워집니다. 양방향 바인딩에 비해 상태 변화의 원인을 추적하기 쉽고, 애플리케이션의 복잡도가 증가해도 관리가 용이합니다. 단방향 흐름은 React의 선언적 특성과 결합하여 안정적이고 유지보수하기 쉬운 애플리케이션을 만듭니다.

## 꼬리질문 대비 (13~15)

**Q13.** JSX 없이도 React를 사용할 수 있나요? 있다면 어떻게?

> 네, 가능합니다. JSX는 React.createElement() 함수 호출의 syntactic sugar이기 때문에, 직접 createElement를 사용하면 됩니다. React.createElement(type, props, children) 형태로 호출하며, type은 태그 이름이나 컴포넌트, props는 속성 객체, children은 자식 요소입니다. 예를 들어 createElement('div', {className: 'container'}, 'Hello')와 같이 작성합니다. 하지만 JSX가 가독성과 생산성 면에서 훨씬 우수하므로 실무에서는 JSX를 사용하는 것이 일반적입니다. TypeScript를 사용할 때는 tsx 확장자를 사용하여 타입 안정성을 확보합니다.

**Q14.** 조건부 렌더링을 구현하는 여러 방법들과 각각의 장단점은?

> 조건부 렌더링은 여러 방법으로 구현할 수 있습니다. 1) if-else 문: 가독성이 좋지만 JSX 내부에서 직접 사용 불가능하고 함수 내에서 미리 처리해야 합니다. 2) 삼항 연산자: JSX 내에서 사용 가능하고 간결하지만, 중첩 시 가독성이 떨어집니다. 3) 논리 AND(&&) 연산자: true일 때만 렌더링하는 간단한 경우에 적합하지만, falsy 값(0, NaN 등)이 렌더링될 수 있어 주의가 필요합니다. 4) 즉시 실행 함수(IIFE): 복잡한 조건 로직에 유용하지만 코드가 장황해질 수 있습니다. 5) switch-case를 함수로 분리: 여러 조건 분기에 적합하고 재사용 가능하지만 별도 함수 정의가 필요합니다. 상황에 따라 가독성과 유지보수성을 고려하여 선택해야 합니다.

**Q15.** React에서 Fragment를 사용하는 이유는 무엇인가요?

> Fragment는 추가 DOM 노드 없이 여러 자식을 그룹화할 수 있게 해줍니다. React 컴포넌트는 하나의 루트 엘리먼트만 반환해야 하는데, 불필요한 div로 감싸면 DOM 구조가 복잡해지고 CSS 레이아웃이 깨질 수 있습니다. Fragment(<React.Fragment> 또는 단축 문법 <>)를 사용하면 실제 DOM에는 렌더링되지 않아 깔끔한 구조를 유지할 수 있습니다. 테이블의 td 요소나 Flexbox/Grid 레이아웃에서 특히 유용합니다. 단축 문법(<>)은 간결하지만 key나 속성을 전달할 수 없고, <React.Fragment>는 key를 전달할 수 있어 리스트 렌더링 시 사용됩니다. Fragment 사용으로 의미 있는 HTML 구조를 유지하고 성능도 향상됩니다.
